<!DOCTYPE html>
<html lang="pt-br">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>IRANCASH | Receitas</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://cdn.sheetjs.com/xlsx-latest/package/dist/xlsx.full.min.js"></script>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600;700;800&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="css/app.css">
  <!-- estilos compartilhados movidos para css/app.css -->
</head>
<body class="bg-gray-50 min-h-screen flex">
  <aside class="sidebar-collapsed bg-white shadow-lg flex flex-col lg:sticky lg:top-0 lg:h-screen lg:overflow-y-auto lg:z-10">
    <div class="flex items-center gap-2 px-6 py-6 border-b">
  <img class="sidebar-logo" src="assets/irancash-logo.png" alt="IRANCASH logo" />
      <span class="logo-text text-xl font-bold text-sky-600">IRANCASH</span>
    </div>
    <nav class="flex-1 px-4 py-6 space-y-2">
      <a href="index.html" class="sidebar-link">
  <img class="sidebar-icon-img" src="assets/dashboard-symbol.png" alt="Dashboard" />
        <span>Dashboard</span>
      </a>
      <!-- Importar link removed (import UI is integrated on this page) -->
      <a href="receitas.html" class="sidebar-link active" aria-current="page">
          <img class="sidebar-icon-img" src="assets/receitas-symbol.png" alt="Receitas" />
        <span>Receitas</span>
      </a>
      <a href="despesas.html" class="sidebar-link">
        <img class="sidebar-icon-img" src="assets/despesas-symbol.png" alt="Despesas" />
        <span>Despesas</span>
      </a>
      <a href="ajuda.html" class="sidebar-link">
        <img class="sidebar-icon-img" src="assets/ajuda-icone.png" alt="Ajuda" />
        <span>Ajuda</span>
      </a>
      <a href="configuracoes.html" class="sidebar-link">
        <img class="sidebar-icon-img" src="assets/configuracao-symbol.png" alt="Configura√ß√µes" />
        <span>Configura√ß√µes</span>
      </a>
    </nav>
    <div class="px-6 py-4 border-t text-xs text-gray-400">
      &copy; 2025 IRANCASH
    </div>
  </aside>

  <main class="flex-1 p-8">
    <h1 class="text-3xl font-bold text-gray-800 mb-6">Receitas</h1>
    <div class="mb-4 md:sticky md:top-6 md:z-40">
      <div class="flex items-center gap-2">
        <button id="btn-toggle-import" type="button" class="inline-flex items-center gap-2 bg-sky-600 hover:bg-sky-700 text-white font-semibold rounded px-4 py-2 shadow-lg">Importar Vendas</button>
        <button id="btn-open-import-config" type="button" class="inline-flex items-center gap-2 bg-white border text-gray-700 font-medium rounded px-3 py-2">Config. importa√ß√£o</button>
      </div>
    </div>

  <div id="import-config-panel" class="max-h-0 opacity-0 -translate-y-2 overflow-hidden transition-all duration-500 ease-[cubic-bezier(.2,1.2,.2,1)] md:transform md:transition md:duration-500 md:scale-95 bg-white rounded-xl shadow p-4 mb-6">
      <h3 class="text-md font-semibold mb-2">Configura√ß√µes de importa√ß√£o</h3>
      <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
        <div>
          <label class="text-sm font-medium">Linha do cabe√ßalho (Cart√µes)</label>
          <input id="headerline-cartao" type="number" min="1" value="2" class="mt-1 rounded border px-2 py-1 w-24" />
          <div class="text-xs text-gray-500 mt-1">Informe o n√∫mero da linha (1 = primeira linha do arquivo) onde est√° o cabe√ßalho para arquivos de cart√£o.</div>
        </div>
        <div>
          <label class="text-sm font-medium">Linha do cabe√ßalho (PIX)</label>
          <input id="headerline-pix" type="number" min="1" value="2" class="mt-1 rounded border px-2 py-1 w-24" />
          <div class="text-xs text-gray-500 mt-1">Informe o n√∫mero da linha (1 = primeira linha do arquivo) onde est√° o cabe√ßalho para arquivos PIX.</div>
        </div>
      </div>
      <div class="mt-3 flex gap-2">
        <button id="save-import-config" class="bg-sky-600 text-white rounded px-3 py-1">Salvar configura√ß√µes</button>
        <button id="open-mapping-cartao" class="bg-white border rounded px-3 py-1">Abrir mapeamento (Cart√£o)</button>
        <button id="open-mapping-pix" class="bg-white border rounded px-3 py-1">Abrir mapeamento (PIX)</button>
      </div>
  <div id="mapping-cartao-panel" class="mt-4 p-3 bg-gray-50 rounded hidden max-h-96 overflow-y-auto">
        <div class="text-sm text-gray-700 mb-2 font-semibold">Mapeamento de colunas (Cart√µes)</div>
        <div id="mapping-cartao-sample" class="mb-2 text-sm text-gray-600">
          <div>Selecione um arquivo de exemplo para popular as colunas, ou selecione o arquivo no painel <strong>Importar Vendas</strong>.</div>
          <div class="mt-2">
            <input id="mapping-cartao-sample-file" type="file" accept=".csv,.xlsx" class="text-sm" />
          </div>
        </div>
        <div id="mapping-cartao-fields" class="grid grid-cols-1 gap-2"></div>
        <div class="flex gap-2 mt-3">
          <button id="save-mapping-cartao" class="bg-sky-600 text-white rounded px-3 py-1 text-sm">Salvar modelo</button>
          <button id="reset-mapping-cartao" class="bg-white border text-sm rounded px-3 py-1">Resetar</button>
        </div>
        <p class="text-xs text-gray-500 mt-2">Dica: selecione a linha de cabe√ßalho correta na primeira coluna do arquivo para popular as op√ß√µes.</p>
      </div>
  <div id="mapping-pix-panel" class="mt-4 p-3 bg-gray-50 rounded hidden max-h-96 overflow-y-auto">
        <div class="text-sm text-gray-700 mb-2 font-semibold">Mapeamento de colunas (PIX)</div>
        <div id="mapping-pix-sample" class="mb-2 text-sm text-gray-600">
          <div>Selecione um arquivo de exemplo para popular as colunas, ou selecione o arquivo no painel <strong>Importar Vendas</strong>.</div>
          <div class="mt-2">
            <input id="mapping-pix-sample-file" type="file" accept=".csv,.xlsx" class="text-sm" />
          </div>
        </div>
        <div id="mapping-pix-fields" class="grid grid-cols-1 gap-2"></div>
        <div class="flex gap-2 mt-3">
          <button id="save-mapping-pix" class="bg-sky-600 text-white rounded px-3 py-1 text-sm">Salvar modelo</button>
          <button id="reset-mapping-pix" class="bg-white border text-sm rounded px-3 py-1">Resetar</button>
        </div>
        <p class="text-xs text-gray-500 mt-2">Dica: selecione a linha de cabe√ßalho correta na primeira coluna do arquivo para popular as op√ß√µes.</p>
      </div>
    </div>

    <!-- Importar: pain√©is de upload (copiado de importar.html) - inicialmente ocultos; exibidos ao clicar em Importar Vendas -->
  <div id="import-panels" class="max-h-0 opacity-0 -translate-y-2 overflow-hidden transition-all duration-500 ease-[cubic-bezier(.2,1.2,.2,1)] md:transform md:transition md:duration-500 md:scale-95 grid grid-cols-1 md:grid-cols-2 gap-6 mb-6">
      <!-- Upload Cart√µes -->
      <div class="bg-white rounded-lg shadow p-5">
        <h2 class="text-md font-semibold text-gray-700 mb-2">Importar Vendas em Cart√µes</h2>
        <p class="text-gray-500 text-sm mb-2">Selecione um arquivo CSV ou Excel</p>
        <input type="file" id="fileInputCartao" accept=".csv,.xlsx" class="mt-1 text-sm" multiple />
        <p id="fileNameCartao" class="mt-1 text-sm text-gray-600"></p>
        <div class="flex gap-2 mt-3">
          <button id="processarBtnCartao" class="bg-sky-600 hover:bg-sky-700 text-white font-semibold rounded px-4 py-2 text-sm" disabled>Processar</button>
        </div>
      
      </div>

      <!-- Upload PIX -->
      <div class="bg-white rounded-lg shadow p-5">
        <h2 class="text-md font-semibold text-gray-700 mb-2">Importar Vendas via PIX</h2>
        <p class="text-gray-500 text-sm mb-2">Selecione um arquivo CSV ou Excel (PIX)</p>
        <input type="file" id="fileInputPix" accept=".csv,.xlsx" class="mt-1 text-sm" multiple />
        <p id="fileNamePix" class="mt-1 text-sm text-gray-600"></p>
        <div class="flex gap-2 mt-3">
          <button id="processarBtnPix" class="bg-sky-600 hover:bg-sky-700 text-white font-semibold rounded px-4 py-2 text-sm" disabled>Processar</button>
        </div>
      
      </div>
      
      
    </div>


    <!-- Toolbar: escolher ano e a√ß√µes -->
    <div class="bg-white rounded-xl shadow p-6 mb-6">
      <div class="flex items-center gap-4">
  <label class="text-sm">Ver receitas do ano:</label>
  <select id="select-anos-receitas" class="rounded border px-2 py-2"></select>
  <button id="btn-ver-ano-receitas" class="bg-sky-600 text-white rounded px-3 py-2">Ver</button>
      </div>
    </div>

    <!-- √Årea principal de resumo (UI movida da Importa√ß√£o) -->
    <div id="lista-receitas-ano" class="bg-white rounded-xl shadow p-6"></div>
  </main>

  <script>
    // Toggle para exibir/ocultar os pain√©is de importa√ß√£o ao clicar em 'Importar Vendas'
    (function(){
      const btn = document.getElementById('btn-toggle-import');
      const panels = document.getElementById('import-panels');
      if (!btn || !panels) return;
      btn.addEventListener('click', function(){
        const isOpen = panels.classList.contains('opacity-100');
        if (!isOpen) {
          panels.classList.remove('max-h-0','opacity-0','-translate-y-2');
          panels.classList.add('max-h-[1000px]','opacity-100','translate-y-0');
          // hide import config panel if open (use transition classes)
          const importCfg = document.getElementById('import-config-panel'); if(importCfg){ importCfg.classList.remove('max-h-[1000px]','opacity-100','translate-y-0'); importCfg.classList.add('max-h-0','opacity-0','-translate-y-2'); importCfg.classList.remove('md:scale-100'); importCfg.classList.add('md:scale-95'); }
          // anima√ß√£o adicional em telas grandes
          panels.classList.remove('md:scale-95'); panels.classList.add('md:scale-100');
          btn.textContent = 'Fechar importa√ß√£o';
          // foco no primeiro input
          const first = panels.querySelector('input, button'); if (first) first.focus();
        } else {
          panels.classList.remove('max-h-[1000px]','opacity-100','translate-y-0');
          panels.classList.add('max-h-0','opacity-0','-translate-y-2');
          // volta escala em telas grandes
          panels.classList.remove('md:scale-100'); panels.classList.add('md:scale-95');
          btn.textContent = 'Importar Vendas';
        }
      });
    })();
  </script>

  <script>
    // --- helpers ---
    function carregarVendasResumo(){
      try {
        // Prefer in-memory cache loaded from IndexedDB (IDB is default backend)
        if(window._vendasResumo_inMemory && Array.isArray(window._vendasResumo_inMemory)) return window._vendasResumo_inMemory;
        const dados = JSON.parse(localStorage.getItem('vendasResumo'))||[];
        return dados;
      } catch(e){ console.error('[DEBUG] Erro ao carregar dados:', e); return[]; }
    }
    // --- IndexedDB helpers (fallback for large datasets) ---
    function idbOpen(){
      return new Promise((resolve,reject)=>{
        if(!window.indexedDB){ return reject(new Error('IndexedDB n√£o suportado')); }
        const req = indexedDB.open('irancash_db', 1);
        req.onupgradeneeded = function(e){
          try{ const db = e.target.result; if(!db.objectStoreNames.contains('kv')) db.createObjectStore('kv',{ keyPath: 'k' }); }catch(err){ /* ignore */ }
        };
        req.onsuccess = function(e){ resolve(e.target.result); };
        req.onerror = function(e){ reject(e.target.error || new Error('IndexedDB open error')); };
      });
    }
    function idbPut(k, v){
      try{
        return idbOpen().then(db => new Promise((res, rej)=>{
          try{
            const tx = db.transaction('kv','readwrite');
            const store = tx.objectStore('kv');
            const req = store.put({ k: String(k), v: v });
            req.onsuccess = ()=>{ try{ db.close(); }catch(e){} res(true); };
            req.onerror = (ev)=>{ try{ db.close(); }catch(e){} rej(ev.target.error || new Error('idb put failed')); };
          }catch(err){ try{ db.close(); }catch(e){} rej(err); }
        }));
      }catch(e){ return Promise.reject(e); }
    }
    function idbGet(k){
      try{
        return idbOpen().then(db => new Promise((res, rej)=>{
          try{
            const tx = db.transaction('kv','readonly');
            const store = tx.objectStore('kv');
            const req = store.get(String(k));
            req.onsuccess = function(ev){ try{ db.close(); }catch(e){} const out = ev.target.result; res(out? out.v : null); };
            req.onerror = function(ev){ try{ db.close(); }catch(e){} rej(ev.target.error || new Error('idb get failed')); };
          }catch(err){ try{ db.close(); }catch(e){} rej(err); }
        }));
      }catch(e){ return Promise.reject(e); }
    }
    function idbDelete(k){
      try{
        return idbOpen().then(db => new Promise((res, rej)=>{
          try{
            const tx = db.transaction('kv','readwrite');
            const store = tx.objectStore('kv');
            const req = store.delete(String(k));
            req.onsuccess = function(){ try{ db.close(); }catch(e){} res(true); };
            req.onerror = function(ev){ try{ db.close(); }catch(e){} rej(ev.target.error || new Error('idb delete failed')); };
          }catch(err){ try{ db.close(); }catch(e){} rej(err); }
        }));
      }catch(e){ return Promise.reject(e); }
    }

    // On init, if we have an IndexedDB marker but no localStorage data, try to migrate async to localStorage so sync loaders work.
    function tryMigrateFromIDB(){
      try{
        // vendasDetalhadas
        if(!localStorage.getItem('vendasDetalhadas') && localStorage.getItem('vendasDetalhadas_idb')){
          idbGet('vendasDetalhadas').then(data => {
            if(!data) return;
            try{
              // write compact form into localStorage for sync access
              if(Array.isArray(data) || (data && data.data)){
                const payload = data.data || data;
                try{ localStorage.setItem('vendasDetalhadas', JSON.stringify(payload)); localStorage.setItem('vendasDetalhadas_last_update', String(Date.now())); }catch(e){}
              }
            }catch(e){}
          }).catch(e=>{});
        }
        // vendasResumoDia
        if(!localStorage.getItem('vendasResumoDia') && localStorage.getItem('vendasResumoDia_idb')){
          idbGet('vendasResumoDia').then(data => {
            if(!data) return;
            try{ const payload = data.data || data; try{ localStorage.setItem('vendasResumoDia', JSON.stringify(payload)); localStorage.setItem('vendasResumoDia_last_update', String(Date.now())); }catch(e){} }catch(e){}
          }).catch(e=>{});
        }
      }catch(e){}
    }

    // Load data from IndexedDB into in-memory caches (used as default backend)
    function loadAllFromIDB(){
      // returns a Promise
      return Promise.resolve().then(async ()=>{
        try{
          // vendasDetalhadas
          try{
            const data = await idbGet('vendasDetalhadas');
            if(data && data.data && Array.isArray(data.data)){
              // expand compact into canonical objects
              try{ window._vendasDetalhadas_inMemory = data.data.map(it => ({ date: it.d||'', time: it.t||'', dateMs: (it.ms!=null)?Number(it.ms):null, valorBruto: (it.v!=null)?(Number(it.v)/100):0, mdr: (it.m!=null)?(Number(it.m)/100):0, source: it.s||'', tipoPagamento: it.p||'', id: it.id||'' })); }catch(e){}
              try{ localStorage.setItem('vendasDetalhadas_idb','1'); }catch(e){}
            }
          }catch(e){ /* ignore */ }
          // vendasResumoDia
          try{
            const data2 = await idbGet('vendasResumoDia');
            if(data2 && data2.data && Array.isArray(data2.data)){
              try{ window._vendasResumoDia_inMemory = data2.data.map(it => ({ anoMesDia: it.a||'', anoMes: (it.a||'').slice(0,7), receitaBruta: (it.b!=null)?(Number(it.b)/100):0, mdr: (it.c!=null)?(Number(it.c)/100):0, source: it.s||'', tipoPagamento: it.p||'' })); }catch(e){}
              try{ localStorage.setItem('vendasResumoDia_idb','1'); }catch(e){}
            }
          }catch(e){ /* ignore */ }
          // vendasResumo (mensal)
          try{
            const data3 = await idbGet('vendasResumo');
            if(data3){ try{ window._vendasResumo_inMemory = data3; try{ localStorage.setItem('vendasResumo_idb','1'); }catch(e){} }catch(e){} }
          }catch(e){ /* ignore */ }
        }catch(e){ /* swallow */ }
        return true;
      });
    }

    // Fecha/recolhe o painel de importa√ß√£o e oculta o painel de 'Ferramentas r√°pidas'
    function closeImportPanelsAndHideQuickTools(){
      try{
        const panels = document.getElementById('import-panels');
        if(panels){
          panels.classList.remove('max-h-[1000px]','opacity-100','translate-y-0');
          panels.classList.add('max-h-0','opacity-0','-translate-y-2');
          panels.classList.remove('md:scale-100'); panels.classList.add('md:scale-95');
        }
        const importCfg = document.getElementById('import-config-panel');
        if(importCfg){ importCfg.classList.remove('max-h-[1000px]','opacity-100','translate-y-0'); importCfg.classList.add('max-h-0','opacity-0','-translate-y-2'); importCfg.classList.remove('md:scale-100'); importCfg.classList.add('md:scale-95'); }
        const quick = document.getElementById('quick-tools-panel'); if(quick) quick.style.display = 'none';
        const btn = document.getElementById('btn-toggle-import'); if(btn) btn.textContent = 'Importar Vendas';
      }catch(e){ /* swallow */ }
    }

    // Migrate existing localStorage datasets (vendasDetalhadas, vendasResumoDia) into IndexedDB
    async function migrateLocalStorageToIDB(){
      try{
        // VENDAS DETALHADAS
        try{
          const existsLegacy = !!localStorage.getItem('vendasDetalhadas') || !!localStorage.getItem('vendasDetalhadas_chunks');
          const alreadyIdb = !!localStorage.getItem('vendasDetalhadas_idb');
          if(existsLegacy && !alreadyIdb){
            console.info('Migrando vendasDetalhadas do localStorage para IndexedDB...');
            // carregarVendasDetalhadas expande formatos e returns canonical array
            const canonical = carregarVendasDetalhadas() || [];
            // build compact representation (short keys, cents)
            const compact = canonical.map(x => ({ d: x.date || '', t: x.time || '', ms: (x.dateMs!=null)?Number(x.dateMs):null, v: Math.round((Number(x.valorBruto||0)||0)*100), s: x.source||'', p: x.tipoPagamento||'', m: Math.round((Number(x.mdr||0)||0)*100), id: x.id||'' }));
            await idbPut('vendasDetalhadas', { format:'compact', data: compact });
            // set marker and in-memory cache
            try{ localStorage.setItem('vendasDetalhadas_idb','1'); }catch(e){}
            try{ window._vendasDetalhadas_inMemory = canonical.slice(); }catch(e){}
            // cleanup localStorage keys to free space
            try{ localStorage.removeItem('vendasDetalhadas'); }catch(e){}
            try{ const meta = JSON.parse(localStorage.getItem('vendasDetalhadas_chunks')||'[]'); for(const k of meta) try{ localStorage.removeItem(k); }catch(e){} localStorage.removeItem('vendasDetalhadas_chunks'); }catch(e){}
            try{ localStorage.removeItem('vendasDetalhadas_format'); }catch(e){}
            try{ localStorage.removeItem('vendasDetalhadas_last_update'); }catch(e){}
            console.info('Migra√ß√£o vendasDetalhadas conclu√≠da.');
          }
        }catch(e){ console.warn('Migra√ß√£o vendasDetalhadas falhou', e); }

        // VENDAS RESUMO DIA
        try{
          const existsResumo = !!localStorage.getItem('vendasResumoDia') || !!localStorage.getItem('vendasResumoDia_chunks');
          const alreadyIdbResumo = !!localStorage.getItem('vendasResumoDia_idb');
          if(existsResumo && !alreadyIdbResumo){
            console.info('Migrando vendasResumoDia do localStorage para IndexedDB...');
            const canonical = carregarVendasResumoDia() || [];
            const compact = canonical.map(x => ({ a: x.anoMesDia || x.date || '', b: Math.round((Number(x.receitaBruta||0)||0)*100), c: Math.round((Number(x.mdr||0)||0)*100), s: x.source||'', p: x.tipoPagamento||'' }));
            await idbPut('vendasResumoDia', { format:'compact', data: compact });
            try{ localStorage.setItem('vendasResumoDia_idb','1'); }catch(e){}
            try{ window._vendasResumoDia_inMemory = canonical.slice(); }catch(e){}
            try{ localStorage.removeItem('vendasResumoDia'); }catch(e){}
            try{ const meta = JSON.parse(localStorage.getItem('vendasResumoDia_chunks')||'[]'); for(const k of meta) try{ localStorage.removeItem(k); }catch(e){} localStorage.removeItem('vendasResumoDia_chunks'); }catch(e){}
            try{ localStorage.removeItem('vendasResumoDia_last_update'); }catch(e){}
            console.info('Migra√ß√£o vendasResumoDia conclu√≠da.');
          }
        }catch(e){ console.warn('Migra√ß√£o vendasResumoDia falhou', e); }

        return true;
      }catch(err){ console.error('migrateLocalStorageToIDB falhou', err); return false; }
    }

    // expose for manual invocation from Console
    window.performFullIDBMigration = migrateLocalStorageToIDB;
    function salvarVendasResumo(v){ 
      try{ localStorage.setItem('vendasResumo', JSON.stringify(v)); }catch(e){}
      try{ localStorage.setItem('vendasResumo_last_update', String(Date.now())); }catch(e){}
      // persist monthly resumo also to IndexedDB and update in-memory cache
      try{ idbPut('vendasResumo', v).then(()=>{ try{ localStorage.setItem('vendasResumo_idb','1'); }catch(e){} }).catch(()=>{}); }catch(e){}
      try{ window._vendasResumo_inMemory = Array.isArray(v) ? v.slice() : null; }catch(e){}
    }
    // Armazenamento por dia (detalhado) - novo comportamento: gravamos vendas por dia em vendasResumoDia
    function carregarVendasResumoDia(){
      try {
        const CHUNKS_META_KEY = 'vendasResumoDia_chunks';
        const chunksMeta = localStorage.getItem(CHUNKS_META_KEY);
        if(chunksMeta){
          try{
            const keys = JSON.parse(chunksMeta) || [];
            let out = [];
            for(const k of keys){
              try{ const part = JSON.parse(localStorage.getItem(k) || '[]'); if(Array.isArray(part)) out = out.concat(part); }catch(e){}
            }
            // detect compact format (short keys) and expand to canonical shape
            try{
              if(out.length>0 && out[0] && (out[0].a !== undefined || out[0].b !== undefined)){
                const expanded = out.map(it => ({
                  anoMesDia: it.a || it.date || '',
                  anoMes: (it.a || '').slice(0,7) || it.anoMes || '',
                  receitaBruta: (it.b != null) ? (Number(it.b)/100) : Number(it.receitaBruta || it.valor || 0),
                  mdr: (it.c != null) ? (Number(it.c)/100) : Number(it.mdr || 0),
                  receitaLiquida: (it.b != null && it.c != null) ? (Number(it.b - (it.c||0))/100) : Number(it.receitaLiquida || 0),
                  source: it.s || it.source || '',
                  tipoPagamento: it.p || it.tipoPagamento || ''
                }));
                return expanded;
              }
            }catch(e){ /* ignore expand errors */ }
            return out;
          }catch(e){ console.error('[DEBUG] erro ao montar chunks vendasResumoDia', e); }
        }
        // legacy single-key
        const raw = JSON.parse(localStorage.getItem('vendasResumoDia') || '[]') || [];
        // if legacy is empty but we have an in-memory fallback from IDB, return it
        try{
          if((!raw || (Array.isArray(raw) && raw.length===0)) && window._vendasResumoDia_inMemory && Array.isArray(window._vendasResumoDia_inMemory)){
            try{
              const mem = window._vendasResumoDia_inMemory || [];
              const mapped = mem.map(function(it){
                try{
                  const anoMesDia = it.anoMesDia || it.date || it.a || '';
                  const anoMes = it.anoMes || (String(anoMesDia||'').slice(0,7)) || '';
                  const receitaBruta = (it.b!=null) ? (Number(it.b)/100) : Number(it.receitaBruta||0);
                  const mdr = (it.c!=null) ? (Number(it.c)/100) : Number(it.mdr||0);
                  const receitaLiquida = (it.receitaLiquida!=null) ? Number(it.receitaLiquida) : ((it.b!=null && it.c!=null) ? ((Number(it.b)-Number(it.c))/100) : Number(it.receitaLiquida||0));
                  return { anoMesDia, anoMes, receitaBruta, mdr, receitaLiquida, source: it.source||it.s||'', tipoPagamento: it.tipoPagamento||it.p||'' };
                }catch(e){ return it; }
              });
              return mapped;
            }catch(e){}
          }
        }catch(e){}
        try{
          if(Array.isArray(raw) && raw.length>0 && raw[0] && (raw[0].a !== undefined || raw[0].b !== undefined)){
            return raw.map(it => ({ anoMesDia: it.a || '', anoMes: (it.a||'').slice(0,7), receitaBruta: (it.b!=null)?(Number(it.b)/100):0, mdr: (it.c!=null)?(Number(it.c)/100):0, receitaLiquida: (it.b!=null && it.c!=null)?((Number(it.b)-Number(it.c))/100):0, source: it.s||'', tipoPagamento: it.p||'' }));
          }
        }catch(e){}
        return raw;
      } catch(e){ console.error('[DEBUG] Erro ao carregar vendasResumoDia', e); return []; }
    }
    function salvarVendasResumoDia(v){
      try{
        const CHUNKS_META_KEY = 'vendasResumoDia_chunks';
        if(!Array.isArray(v)) v = [];
        // compact representation: a=anoMesDia, b=receitaBruta(cents), c=mdr(cents), s=source, p=tipo
        const compact = v.map(x => ({ a: x.anoMesDia || x.date || '', b: Math.round((Number(x.receitaBruta||x.valor||0)||0) * 100), c: Math.round((Number(x.mdr||0)||0) * 100), s: x.source||'', p: x.tipoPagamento||'' }));
  // Persist compact copy to IndexedDB asynchronously (IDB is the default backend)
  try{ idbPut('vendasResumoDia', { format: 'compact', data: compact }).then(()=>{ try{ localStorage.setItem('vendasResumoDia_idb','1'); }catch(e){} }).catch(()=>{}); }catch(e){}
  // update in-memory cache
  try{ window._vendasResumoDia_inMemory = Array.isArray(v) ? v.slice() : null; }catch(e){}
        // try single-key write first
        try{ localStorage.setItem('vendasResumoDia', JSON.stringify(compact)); localStorage.setItem('vendasResumoDia_last_update', String(Date.now())); try{ localStorage.removeItem(CHUNKS_META_KEY); }catch(e){} return true; }catch(e){}

        // chunked persistence, adaptive
        try{
          try{ const prev = localStorage.getItem(CHUNKS_META_KEY); if(prev){ const keys = JSON.parse(prev)||[]; for(const k of keys) try{ localStorage.removeItem(k); }catch(e){} } }catch(e){}
          let CHUNK_SIZE = 500;
          while(CHUNK_SIZE >= 20){
            try{
              const chunkKeys = [];
              for(let i=0;i<compact.length;i+=CHUNK_SIZE){ const slice = compact.slice(i,i+CHUNK_SIZE); const key = `vendasResumoDia_chunk_${Math.floor(i/CHUNK_SIZE)}`; localStorage.setItem(key, JSON.stringify(slice)); chunkKeys.push(key); }
              localStorage.setItem(CHUNKS_META_KEY, JSON.stringify(chunkKeys));
              localStorage.setItem('vendasResumoDia_last_update', String(Date.now()));
              try{ localStorage.removeItem('vendasResumoDia'); }catch(e){}
              return true;
            }catch(e){ // clear partial and reduce size
              try{ const keys = JSON.parse(localStorage.getItem(CHUNKS_META_KEY) || '[]'); for(const k of keys) try{ localStorage.removeItem(k); }catch(_){}}catch(_){ }
              CHUNK_SIZE = Math.floor(CHUNK_SIZE/2);
            }
          }
          // fallback to IndexedDB if localStorage chunking failed
          try{
            // ensure in-memory cache updated and persist to IndexedDB
            try{ window._vendasResumoDia_inMemory = Array.isArray(v) ? v.slice() : null; }catch(e){}
            try{
              // Await idbPut so we can refresh UI after persistence
              idbPut('vendasResumoDia', { format: 'compact', data: compact }).then(()=>{
                try{ localStorage.setItem('vendasResumoDia_idb','1'); }catch(e){}
                // attempt to refresh in-memory caches / UI from IDB to ensure page reflects new data
                try{ loadAllFromIDB().then(()=>{ try{ atualizarSelectAnos(); const sel = document.getElementById('select-anos-receitas'); if(sel && sel.value) renderizarReceitasAno(sel.value); }catch(e){} }).catch(()=>{}); }catch(e){}
              }).catch(err=>{ console.error('IDB save failed', err); });
            }catch(e){ console.error('IDB put failed', e); }
          }catch(e){}
          // fallback to IndexedDB used; treat as success for the import flow (UI updated from IDB)
          console.info('vendasResumoDia salvo em IndexedDB (fallback ap√≥s quota excedida)');
          return true;
        }catch(e){ console.error('Erro ao salvar vendasResumoDia', e); return false; }
      }catch(err){ console.error('salvarVendasResumoDia falhou', err); return false; }
    }

    // Agrega vendasResumoDia em vendasResumo (mensal) ‚Äî mant√©m compatibilidade com UI atual
    function computeMonthlyResumoFromDaily(){
      try{
        const daily = carregarVendasResumoDia();
        const map = new Map();
        for(const d of daily){
          // d.anoMesDia esperado como 'YYYY/MM/DD' ou tente extrair de d.anoMes
          let anoMesDia = d.anoMesDia || d.date || d.anoMes || '';
          // if date ISO available in d.date, prefer it
          if (d.date && !d.anoMesDia){
            try{ const dt = new Date(d.date); if(!isNaN(dt.getTime())){ const y = dt.getFullYear(); const m = String(dt.getMonth()+1).padStart(2,'0'); const day = String(dt.getDate()).padStart(2,'0'); anoMesDia = `${y}/${m}/${day}`; } }catch(e){}
          }
          // normalize to YYYY/MM/DD
          let parts = String(anoMesDia||'').split('/');
          if(parts.length >= 3){
            const ano = parts[0]; const mes = parts[1].padStart(2,'0'); // day = parts[2]
            const anoMes = `${ano}/${mes}`;
            const key = `${anoMes}||${d.source||''}||${d.tipoPagamento||''}`;
            if(!map.has(key)) map.set(key, { anoMes, source: d.source||'', tipoPagamento: d.tipoPagamento||'', receitaBruta:0, mdr:0, receitaLiquida:0 });
            const obj = map.get(key);
            obj.receitaBruta += Number(d.receitaBruta||d.valor||0);
            obj.mdr += Number(d.mdr||0);
            obj.receitaLiquida = obj.receitaBruta - obj.mdr;
            map.set(key, obj);
          }
        }
        const monthly = Array.from(map.values());
        // salvar em vendasResumo para UI
        salvarVendasResumo(monthly);
        return monthly;
      }catch(e){ console.error('Erro ao computar resumo mensal a partir de di√°rio', e); return []; }
    }
    function orderMonths(values){ 
      // canonical month names without diacritics
      const monthNames = ['janeiro','fevereiro','marco','abril','maio','junho','julho','agosto','setembro','outubro','novembro','dezembro'];
      function normalize(s){ try { return String(s||'').toLowerCase().normalize('NFD').replace(/\p{Diacritic}/gu,'').trim(); } catch(e) { return String(s||'').toLowerCase().replace(/√ß/g,'c').trim(); } }
      function idx(v){ 
        if(v==null) return 99; 
        const s = String(v).trim(); 
        const n = parseInt(s,10); 
        if(!isNaN(n) && n>=1 && n<=12) return n-1; 
        const norm = normalize(s);
        const i = monthNames.indexOf(norm);
        return i>=0?i:99;
      }
      return values.slice().sort((a,b)=>idx(a)-idx(b)); 
    }
    function mesIndex(v){ 
      const monthNames = ['janeiro','fevereiro','marco','abril','maio','junho','julho','agosto','setembro','outubro','novembro','dezembro'];
      function normalize(s){ try { return String(s||'').toLowerCase().normalize('NFD').replace(/\p{Diacritic}/gu,'').trim(); } catch(e) { return String(s||'').toLowerCase().replace(/√ß/g,'c').trim(); } }
      if(v==null) return 99; 
      const s = String(v).trim(); 
      const n = parseInt(s,10); 
      if(!isNaN(n) && n>=1 && n<=12) return n-1; 
      const norm = normalize(s);
      const i = monthNames.indexOf(norm);
      return i>=0?i:99; 
    }

    function atualizarSelectAnos(){ 
      const sel=document.getElementById('select-anos-receitas'); 
      const all=carregarVendasResumo(); 
      const anosSet = new Set(all.map(v=> (v.anoMes && v.anoMes.split('/')[0]) ).filter(Boolean)); 
      const anos=Array.from(anosSet).sort((a,b)=>Number(b)-Number(a)); 
      sel.innerHTML=''; 
      if(anos.length===0){
        const opt=document.createElement('option'); 
        opt.value=''; 
        opt.textContent='Nenhum registro'; 
        sel.appendChild(opt); 
        return;
      } 
      anos.forEach(a=>{
        const opt=document.createElement('option'); 
        opt.value=a; 
        opt.textContent=a; 
        sel.appendChild(opt);
      }); 
      const anoAtual=String(new Date().getFullYear()); 
      if(anos.includes(anoAtual)) sel.value=anoAtual; 
    }

    function renderizarReceitasAno(ano){ 
      const container=document.getElementById('lista-receitas-ano'); 
      container.innerHTML=''; 
      // Sempre renderizar cabe√ßalho da tabela mesmo que n√£o haja dados ‚Äî mostraremos linhas vazias/rodap√© com zeros
      if(!ano){
        // se nenhum ano for informado, usa o ano atual como default (permite visualizar o cabe√ßalho)
        ano = String(new Date().getFullYear());
      }
      const all = carregarVendasResumo().map(v=> ({...v})).filter(v=> (v.anoMes && String(v.anoMes).startsWith(String(ano)+"/"))); 
  // if no data, we'll still render the table header and an empty body (user requested header instead of message)
      // meses, fontes, tipos
      const meses = orderMonths(Array.from(new Set(all.map(v=> v.anoMes && v.anoMes.split('/')[1]).filter(Boolean))).map(m=>{
        const num = parseInt(m,10); if(!isNaN(num)) return ['Janeiro','Fevereiro','Mar√ßo','Abril','Maio','Junho','Julho','Agosto','Setembro','Outubro','Novembro','Dezembro'][num-1]; return m; }).filter(Boolean));
      const fontes = Array.from(new Set(all.map(v=> v.source=== 'cartao' ? 'Cart√µes' : v.source==='pix' ? 'PIX' : (v.source||'')).filter(Boolean))).sort((a,b)=>a.localeCompare(b));
      const tipos = Array.from(new Set(all.map(v=> v.tipoPagamento || '').filter(Boolean))).sort((a,b)=>a.localeCompare(b));
      const filtros = { mes:'Todos', fonte:'Todos', tipo:'Todos' };

      // toolbar (actions only) ‚Äî filters are rendered inside the table header to match Configura√ß√µes
      const toolbar = document.createElement('div'); toolbar.className='flex justify-between items-center mb-3';
      toolbar.innerHTML = `<div class="flex gap-2 items-center">
          <span class='text-sm font-semibold'>Filtros</span>
        </div>
        <div class="flex gap-2">
          <button id='btn-limpar-filtros-rec' class='text-sky-700 text-xs'>Limpar filtros</button>
          <button id='btn-delete-selected-rec' class='text-red-600 text-xs'>Excluir selecionados</button>
        </div>`;
      container.appendChild(toolbar);

      // table
      const table = document.createElement('table'); table.className='min-w-full divide-y divide-gray-200 text-sm';
      table.innerHTML = `<thead>
          <tr class='bg-gray-50'>
            <th class='px-2 py-2'><input id='selectAllRec' type='checkbox' /></th>
            <th class='px-2 py-2 text-left'>Ano</th>
            <th class='px-2 py-2 text-left'>M√™s</th>
            <th class='px-2 py-2 text-left'>Fonte</th>
            <th class='px-2 py-2 text-left'>Tipo</th>
            <th class='px-2 py-2 text-right'>Receita Bruta</th>
            <th class='px-2 py-2 text-right'>MDR</th>
            <th class='px-2 py-2 text-right'>Receita L√≠quida</th>
            <th class='px-2 py-2'></th>
          </tr>
          <tr class='bg-white'>
            <th class='px-2 py-2'></th>
            <th class='px-2 py-2'></th>
            <th class='px-2 py-2'>
              <select id='filtro-mes-rec' class='filter w-full'>${['Todos'].concat(meses).map(m=>`<option value="${m}">${m}</option>`).join('')}</select>
            </th>
            <th class='px-2 py-2'>
              <select id='filtro-fonte-rec' class='filter w-full'>${['Todos'].concat(fontes).map(f=>`<option value="${f}">${f}</option>`).join('')}</select>
            </th>
            <th class='px-2 py-2'>
              <select id='filtro-tipo-rec' class='filter w-full'>${['Todos'].concat(tipos).map(t=>`<option value="${t}">${t}</option>`).join('')}</select>
            </th>
            <th class='px-2 py-2'></th>
            <th class='px-2 py-2'></th>
            <th class='px-2 py-2 text-right'></th>
            <th class='px-2 py-2 text-right'></th>
          </tr>
        </thead>
        <tbody></tbody>`;

      container.appendChild(table);

      // container for weekly totals (dias da semana)
      let weeklyContainer = container.querySelector('#weekly-totals-rec');
      if(!weeklyContainer){
        weeklyContainer = document.createElement('div');
        weeklyContainer.id = 'weekly-totals-rec';
        weeklyContainer.className = 'mt-4 bg-white rounded p-4 border';
        container.appendChild(weeklyContainer);
      }

      // container for period totals (per√≠odo do dia)
      let periodoContainer = container.querySelector('#periodo-totals-rec');
      if(!periodoContainer){
        periodoContainer = document.createElement('div');
        periodoContainer.id = 'periodo-totals-rec';
        periodoContainer.className = 'mt-4 bg-white rounded p-4 border';
        container.appendChild(periodoContainer);
      }
      // container for consistency note
      let consistencyContainer = container.querySelector('#totals-consistency-rec');
      if(!consistencyContainer){
        consistencyContainer = document.createElement('div');
        consistencyContainer.id = 'totals-consistency-rec';
        consistencyContainer.className = 'mt-2 text-xs text-gray-600';
        container.appendChild(consistencyContainer);
      }

        // checagem de consist√™ncia entre as tr√™s vis√µes (mensal, dia da semana, per√≠odo do dia)
        (function reconcileTotalsUI(){
          try{
            // Se n√£o houver um filtro de m√™s selecionado corretamente, limpa a nota
            const monthIdx = mesIndex(filtros.mes);
            if(!filtros.mes || filtros.mes === 'Todos' || monthIdx === 99) {
              if(typeof consistencyContainer !== 'undefined' && consistencyContainer){
                consistencyContainer.textContent = '';
              }
              return;
            }
            const mesNum = monthIdx + 1;
            const anoStr = String(ano);
            const anoMes = `${anoStr}/${String(mesNum).padStart(2,'0')}`;

            // Calcula o total principal diretamente a partir da tabela renderizada (n√£o depende de vari√°veis externas)
            let totalPrincipal = 0;
            try{
              const tableEl = container.querySelector('table');
              if(tableEl){
                // tenta obter valor do tfoot; se n√£o, soma as c√©lulas da coluna "Receita Bruta"
                const tfootVal = tableEl.querySelector('tfoot td');
                if(tfootVal){
                  const txt = tfootVal.textContent || tfootVal.innerText || '';
                  const m = txt.replace(/[^0-9,.-]/g,'').replace(/\./g,'').replace(',', '.');
                  totalPrincipal = Number(m) || 0;
                } else {
                  // soma valores das linhas (coluna que cont√©m 'R$ ')
                  const rows = tableEl.querySelectorAll('tbody tr');
                  rows.forEach(r=>{
                    const cells = r.querySelectorAll('td');
                    if(cells && cells.length>=6){
                      const txt = cells[5].textContent || '';
                      const m = txt.replace(/[^0-9,.-]/g,'').replace(/\./g,'').replace(',', '.');
                      totalPrincipal += Number(m) || 0;
                    }
                  });
                }
              }
            }catch(e){ console.warn('Erro ao calcular totalPrincipal a partir da tabela', e); totalPrincipal = 0; }

            // Total semanal: derive a partir de vendasResumoDia (mesma fonte usada para a tabela semanal)
            const weeklySums = getSomaSemanalPorMes(anoMes);
            const totalSemanal = ['domingo','segunda','ter√ßa','quarta','quinta','sexta','s√°bado'].reduce((acc,k)=> acc + Number(weeklySums[k]||0), 0);

            // Total por per√≠odo: derive usando a fun√ß√£o existente (que usa vendasDetalhadas)
            const periodoSums = getSomaPeriodoPorMes(anoMes);
            const totalPeriodo = ['Madrugada','Manh√£','Tarde','Noite'].reduce((acc,k)=> acc + Number(periodoSums[k]||0), 0);

            // Diagn√≥stico adicional: comparar com vendasDetalhadas e vendasResumoDia (contagens e somas)
            const detalhes = (typeof carregarVendasDetalhadas === 'function') ? carregarVendasDetalhadas() || [] : (JSON.parse(localStorage.getItem('vendasDetalhadas')||'[]')||[]);
            let countDetalhadas = 0, countWithTime = 0;
            let sumDetalhadasTotal = 0, sumDetalhadasWithTime = 0;
            for(const tx of detalhes){
              if(!tx) continue;
              // tentar obter data
              let d = null;
              if(tx.dateMs) d = new Date(Number(tx.dateMs)); else if(tx.date) d = parseToJSDate(tx.date) || new Date(tx.date);
              if(!d || isNaN(d.getTime())){
                const ex = (typeof extractDateTime === 'function') ? extractDateTime(tx.date || tx.time || '') : {dateObj: null, timeStr: null};
                d = ex && ex.dateObj ? ex.dateObj : d;
              }
              if(!d || isNaN(d.getTime())) continue;
              const ym = `${d.getFullYear()}/${String(d.getMonth()+1).padStart(2,'0')}`;
              if(String(ym) !== String(anoMes)) continue;
              countDetalhadas++;
              const val = Number(tx.valorBruto || tx.value || tx.valor || tx.receitaBruta || 0) || 0;
              sumDetalhadasTotal += val;
              // considera que existe hora se tivermos campo time ou extra√ß√£o retornou timeStr
              let hasTime = false;
              if(tx.time && String(tx.time).trim().length>0) hasTime = true;
              else {
                const ex = (typeof extractDateTime === 'function') ? extractDateTime(tx.date || tx.time || '') : null; if(ex && ex.timeStr) hasTime = true;
              }
              if(hasTime){ countWithTime++; sumDetalhadasWithTime += val; }
            }
            const resumoDia = (typeof carregarVendasResumoDia === 'function') ? carregarVendasResumoDia() || [] : (JSON.parse(localStorage.getItem('vendasResumoDia')||'[]')||[]);
            const resumoDiaFiltered = resumoDia.filter(d => {
              try{ const ym = String(d.anoMes||d.anoMesDia||'').slice(0,7); return String(ym) === String(anoMes); }catch(e){ return false; }
            });
            const countResumoDia = resumoDiaFiltered.length;
            const sumResumoDia = resumoDiaFiltered.reduce((acc,x)=> acc + Number(x.receitaBruta || x.valor || 0), 0);

            const dif1 = Math.abs(totalPrincipal - totalSemanal);
            const dif2 = Math.abs(totalPrincipal - totalPeriodo);
            const ok = (dif1 < 0.005) && (dif2 < 0.005); // toler√¢ncia centesimal

            if(typeof consistencyContainer !== 'undefined' && consistencyContainer){
              if(ok){
                consistencyContainer.innerHTML = `<span class="inline-block rounded px-2 py-1 bg-green-50 text-green-700 border border-green-200">Totais consistentes</span>`;
              }else{
                // mensagem detalhada explicativa
                let detailsHtml = `Mensal: R$ ${totalPrincipal.toLocaleString('pt-BR',{minimumFractionDigits:2})} ‚Äî Semanal: R$ ${totalSemanal.toLocaleString('pt-BR',{minimumFractionDigits:2})} ‚Äî Per√≠odo: R$ ${totalPeriodo.toLocaleString('pt-BR',{minimumFractionDigits:2})}`;
                let diag = `<div class="text-xs text-gray-600 mt-2">`;
                diag += `<div>Registros em <strong>vendasResumoDia</strong>: ${countResumoDia} ‚Äî Soma bruta: R$ ${sumResumoDia.toLocaleString('pt-BR',{minimumFractionDigits:2})}</div>`;
                diag += `<div>Registros em <strong>vendasDetalhadas</strong> (m√™s): ${countDetalhadas} ‚Äî Soma: R$ ${sumDetalhadasTotal.toLocaleString('pt-BR',{minimumFractionDigits:2})}</div>`;
                diag += `<div>Registros em vendasDetalhadas com <strong>hora</strong>: ${countWithTime} ‚Äî Soma com hora: R$ ${sumDetalhadasWithTime.toLocaleString('pt-BR',{minimumFractionDigits:2})}</div>`;
                if(Math.abs(sumDetalhadasWithTime - totalPeriodo) > 0.01){
                  diag += `<div class="mt-1 text-xs text-yellow-700">Observa√ß√£o: o total por per√≠odo considera apenas transa√ß√µes com informa√ß√£o de hora. Neste m√™s, apenas R$ ${sumDetalhadasWithTime.toLocaleString('pt-BR',{minimumFractionDigits:2})} t√™m hora registrada, por isso o total por per√≠odo √© menor que o total mensal.</div>`;
                }
                diag += `</div>`;

                consistencyContainer.innerHTML = `<div class="space-y-1"><div class="inline-block rounded px-2 py-1 bg-yellow-50 text-yellow-800 border border-yellow-200">Diferen√ßa detectada entre totais.</div><div class="text-xs text-gray-600">${detailsHtml}</div>${diag}</div>`;
              }
            }
          }catch(e){ console.warn('reconcileTotalsUI falhou', e); }
        })();


        // fun√ß√£o que aplica filtros e renderiza linhas / totais / pain√©is
        function aplicaEFazRender(){ 
          const tbody = table.querySelector('tbody'); 
          tbody.innerHTML=''; 
          let view = all.filter(v=>{
            if(filtros.mes !== 'Todos'){ const mes = (v.anoMes && v.anoMes.split('/')[1]) || ''; const nome = (Number(mes)>=1? ['Janeiro','Fevereiro','Mar√ßo','Abril','Maio','Junho','Julho','Agosto','Setembro','Outubro','Novembro','Dezembro'][Number(mes)-1] : mes); if(String(nome)!==String(filtros.mes)) return false; }
            if(filtros.fonte !== 'Todos'){ const fonte = v.source==='cartao'?'Cart√µes': v.source==='pix'?'PIX': (v.source||''); if(String(fonte)!==String(filtros.fonte)) return false; }
            if(filtros.tipo !== 'Todos'){ if(String(v.tipoPagamento||'')!==String(filtros.tipo)) return false; }
            return true;
          });
          // ordenar por m√™s
          view.sort((a,b)=> mesIndex((a.anoMes||'').split('/')[1]) - mesIndex((b.anoMes||'').split('/')[1]));
          view.forEach((v) => {
            const ano = v.anoMes? v.anoMes.split('/')[0]:'';
            const mesNum = v.anoMes? Number(v.anoMes.split('/')[1]): null; 
            const mesNome = mesNum? ['Janeiro','Fevereiro','Mar√ßo','Abril','Maio','Junho','Julho','Agosto','Setembro','Outubro','Novembro','Dezembro'][mesNum-1] : '';
            const tr = document.createElement('tr'); 
            tr.className='odd:bg-white even:bg-gray-50';
            tr.innerHTML = `
              <td class='px-2 py-2'><input type='checkbox' class='rowCheckbox' data-key='${v.anoMes}__${v.source}__${v.tipoPagamento||''}' /></td>
              <td class='px-2 py-2'>${ano}</td>
              <td class='px-2 py-2'>${mesNome}</td>
              <td class='px-2 py-2'>${v.source==='cartao'?'Cart√µes':v.source==='pix'?'PIX':(v.source||'')}</td>
              <td class='px-2 py-2'>${v.tipoPagamento||''}</td>
              <td class='px-2 py-2 text-right'>R$ ${Number(v.receitaBruta||0).toLocaleString('pt-BR',{minimumFractionDigits:2})}</td>
              <td class='px-2 py-2 text-right'>R$ ${Number(v.mdr||0).toLocaleString('pt-BR',{minimumFractionDigits:2})}</td>
              <td class='px-2 py-2 text-right font-semibold text-sky-700'>R$ ${Number(v.receitaLiquida||0).toLocaleString('pt-BR',{minimumFractionDigits:2})}</td>
              <td class='px-2 py-2 col-actions'><button class='btn-del-rec text-gray-600 hover:text-red-600' data-key='${v.anoMes}__${v.source}__${v.tipoPagamento||''}'>üóë</button></td>`;
            tbody.appendChild(tr);
          });
          // totais: soma de Receita Bruta, MDR e Receita L√≠quida
          const totalBruta = view.reduce((acc,x)=> acc + Number(x.receitaBruta||0),0);
          const totalMdr = view.reduce((acc,x)=> acc + Number(x.mdr||0),0);
          const totalLiquida = view.reduce((acc,x)=> acc + Number(x.receitaLiquida||0),0);
          const oldT = table.querySelector('tfoot'); if(oldT) oldT.remove(); 
          const tfoot = document.createElement('tfoot'); 
          tfoot.innerHTML = `
            <tr class='bg-gray-50 font-semibold'>
              <td class='px-2 py-2' colspan='5'></td>
              <td class='px-2 py-2 text-right'>R$ ${totalBruta.toLocaleString('pt-BR',{minimumFractionDigits:2})}</td>
              <td class='px-2 py-2 text-right'>R$ ${totalMdr.toLocaleString('pt-BR',{minimumFractionDigits:2})}</td>
              <td class='px-2 py-2 text-right'>R$ ${totalLiquida.toLocaleString('pt-BR',{minimumFractionDigits:2})}</td>
              <td class='px-2 py-2'></td>
            </tr>`; 
          table.appendChild(tfoot);

          // render weekly totals for selected month
          (function renderWeeklyTotals(){
            try{
              const wrap = weeklyContainer;
              wrap.innerHTML = '';
              if(!filtros.mes || filtros.mes === 'Todos'){
                wrap.innerHTML = `<div class="text-sm text-gray-500">Selecione um m√™s no filtro acima para ver o total por dia da semana.</div>`;
                return;
              }
              // get month index (0-based) then convert to 1-based
              const monthIdx = mesIndex(filtros.mes);
              if(monthIdx === 99){ wrap.innerHTML = `<div class="text-sm text-gray-500">M√™s inv√°lido.</div>`; return; }
              const mesNum = monthIdx + 1;
              const anoStr = String(ano);
              const anoMes = `${anoStr}/${String(mesNum).padStart(2,'0')}`;
              const sums = getSomaSemanalPorMes(anoMes);
              // build table
              const tbl = document.createElement('table'); tbl.className = 'min-w-full text-sm';
              tbl.innerHTML = `<thead><tr class='bg-gray-50'><th class='px-2 py-2 text-left'>Dia da semana</th><th class='px-2 py-2 text-right'>Total (R$)</th></tr></thead><tbody></tbody>`;
              const tb = tbl.querySelector('tbody');
              const order = ['domingo','segunda','ter√ßa','quarta','quinta','sexta','s√°bado'];
              order.forEach(dn=>{
                const tr = document.createElement('tr'); tr.className='odd:bg-white even:bg-gray-50';
                const val = Number(sums[dn]||0);
                tr.innerHTML = `<td class='px-2 py-2'>${dn.charAt(0).toUpperCase()+dn.slice(1)}</td><td class='px-2 py-2 text-right font-semibold'>R$ ${val.toLocaleString('pt-BR',{minimumFractionDigits:2})}</td>`;
                tb.appendChild(tr);
              });
              // linha de total geral
              const totalSum = order.reduce((acc, dn) => acc + Number(sums[dn]||0), 0);
              const trTotal = document.createElement('tr');
              trTotal.className = 'bg-gray-50 font-semibold';
              trTotal.innerHTML = `<td class='px-2 py-2'>Total</td><td class='px-2 py-2 text-right'>R$ ${totalSum.toLocaleString('pt-BR',{minimumFractionDigits:2})}</td>`;
              tb.appendChild(trTotal);
              wrap.appendChild(tbl);
            }catch(e){ console.warn('Erro ao renderizar totais semanais', e); }
          })();
          // render period totals for selected month (Per√≠odo do Dia)
          (function renderPeriodoTotals(){
            try{
              const wrap = periodoContainer;
              wrap.innerHTML = '';
              if(!filtros.mes || filtros.mes === 'Todos'){
                wrap.innerHTML = `<div class="text-sm text-gray-500">Selecione um m√™s no filtro acima para ver o total por per√≠odo do dia.</div>`;
                return;
              }
              const monthIdx = mesIndex(filtros.mes);
              if(monthIdx === 99){ wrap.innerHTML = `<div class="text-sm text-gray-500">M√™s inv√°lido.</div>`; return; }
              const mesNum = monthIdx + 1;
              const anoStr = String(ano);
              const anoMes = `${anoStr}/${String(mesNum).padStart(2,'0')}`;
              const sums = getSomaPeriodoPorMes(anoMes);
              // tabela
              const tbl = document.createElement('table'); tbl.className = 'min-w-full text-sm';
              tbl.innerHTML = `<thead><tr class='bg-gray-50'>
                                  <th class='px-2 py-2 text-left'>Per√≠odo do dia</th>
                                  <th class='px-2 py-2 text-right'>Total (R$)</th>
                                </tr></thead><tbody></tbody>`;
              const tb = tbl.querySelector('tbody');
              const order = ['Madrugada','Manh√£','Tarde','Noite'];
              order.forEach(nome=>{
                const tr = document.createElement('tr'); tr.className='odd:bg-white even:bg-gray-50';
                const val = Number(sums[nome]||0);
                tr.innerHTML = `<td class='px-2 py-2'>${nome}</td>
                                <td class='px-2 py-2 text-right font-semibold'>R$ ${val.toLocaleString('pt-BR',{minimumFractionDigits:2})}</td>`;
                tb.appendChild(tr);
              });
              const totalSum = order.reduce((acc, k) => acc + Number(sums[k]||0), 0);
              const trTotal = document.createElement('tr');
              trTotal.className = 'bg-gray-50 font-semibold';
              trTotal.innerHTML = `<td class='px-2 py-2'>Total</td>
                                   <td class='px-2 py-2 text-right'>R$ ${totalSum.toLocaleString('pt-BR',{minimumFractionDigits:2})}</td>`;
              tb.appendChild(trTotal);
              wrap.appendChild(tbl);
            }catch(e){ console.warn('Erro ao renderizar totais por per√≠odo', e); }
          })();

        // sele√ß√£o
        const selectAll = container.querySelector('#selectAllRec'); 
        const rowCheckboxes = Array.from(container.querySelectorAll('.rowCheckbox'));
        if(selectAll){ 
          selectAll.checked = rowCheckboxes.length>0 && rowCheckboxes.every(r=>r.checked); 
          // usar assignment para evitar m√∫ltiplos listeners ao re-render
          selectAll.onchange = function(e){
            rowCheckboxes.forEach(cb=>{
              cb.checked = e.target.checked; 
              const tr=cb.closest('tr'); 
              if(tr) tr.classList.toggle('bg-sky-100', e.target.checked);
            });
          };
        }
        rowCheckboxes.forEach(cb=> cb.addEventListener('change', ()=>{
          if(selectAll) selectAll.checked = rowCheckboxes.length>0 && rowCheckboxes.every(r=>r.checked); 
          const tr=cb.closest('tr'); if(tr) tr.classList.toggle('bg-sky-100', cb.checked);
        }));

        // excluir selecionados
        const btnDelSel = container.querySelector('#btn-delete-selected-rec'); 
        if(btnDelSel) btnDelSel.onclick = function(){
          const checks = Array.from(container.querySelectorAll('.rowCheckbox:checked'));
          if(checks.length===0){ alert('Nenhuma receita selecionada.'); return; }
          if(!confirm(`Confirma exclus√£o de ${checks.length} item(s)?`)) return;
          const keys = checks.map(c=> c.dataset.key);
          let allRec = carregarVendasResumo();
          allRec = allRec.filter(v => !keys.includes(`${v.anoMes}__${v.source}__${v.tipoPagamento||''}`));
          salvarVendasResumo(allRec);
          // remover tamb√©m as despesas MDR autom√°ticas relacionadas a essas vendas
          try{ removerDespesasMdrPorVendasKeys(keys); }catch(e){ console.warn('Erro ao remover despesas MDR ao excluir selecionados', e); }
          // remover tamb√©m as vendas detalhadas relacionadas para evitar re-importa√ß√£o futura
          try{ removerVendasDetalhadasPorVendasResumoKeys(keys); }catch(e){ console.warn('Erro ao remover vendas detalhadas ao excluir selecionados', e); }
          atualizarSelectAnos(); renderizarReceitasAno(ano);
        };

        // excluir linha
        container.querySelectorAll('.btn-del-rec').forEach(b => b.addEventListener('click', (ev)=>{
          const key = ev.currentTarget.dataset.key; 
          if(!confirm('Confirma exclus√£o deste item?')) return; 
          let allRec = carregarVendasResumo(); 
          allRec = allRec.filter(v => !( `${v.anoMes}__${v.source}__${v.tipoPagamento||''}` === key )); 
          salvarVendasResumo(allRec); 
          // remover tamb√©m a despesa MDR autom√°tica associada a esta venda (se existir)
          try{ removerDespesasMdrPorVendasKeys([key]); }catch(e){ console.warn('Erro ao remover despesa MDR ao excluir item', e); }
          // remover tamb√©m as vendas detalhadas relacionadas
          try{ removerVendasDetalhadasPorVendasResumoKeys([key]); }catch(e){ console.warn('Erro ao remover vendas detalhadas ao excluir item', e); }
          atualizarSelectAnos(); 
          renderizarReceitasAno(ano);
        }));

        // filtros
        const filtroMesEl = container.querySelector('#filtro-mes-rec');
        const filtroFonteEl = container.querySelector('#filtro-fonte-rec');
        const filtroTipoEl = container.querySelector('#filtro-tipo-rec');
        const btnLimparEl = container.querySelector('#btn-limpar-filtros-rec');
        if(filtroMesEl) filtroMesEl.onchange = function(e){ filtros.mes = e.target.value; aplicaEFazRender(); };
        if(filtroFonteEl) filtroFonteEl.onchange = function(e){ filtros.fonte = e.target.value; aplicaEFazRender(); };
        if(filtroTipoEl) filtroTipoEl.onchange = function(e){ filtros.tipo = e.target.value; aplicaEFazRender(); };
        if(btnLimparEl) btnLimparEl.onclick = function(){
          filtros.mes='Todos'; filtros.fonte='Todos'; filtros.tipo='Todos'; 
          if(filtroMesEl) filtroMesEl.value='Todos';
          if(filtroFonteEl) filtroFonteEl.value='Todos';
          if(filtroTipoEl) filtroTipoEl.value='Todos';
          aplicaEFazRender();
        };
      }
      aplicaEFazRender();

      // garante visibilidade
      setTimeout(() => {
        const table = container.querySelector('table');
        if (table) {
          table.style.display = 'table';
          table.style.visibility = 'visible';
          table.style.opacity = '1';
        }
      }, 50);
    }

    // init
    document.getElementById('btn-ver-ano-receitas').addEventListener('click', ()=>{ 
      const sel=document.getElementById('select-anos-receitas'); 
      renderizarReceitasAno(sel.value); 
      setTimeout(() => {
        const table = document.querySelector('#lista-receitas-ano table');
        if (table) {
          table.style.display = 'table';
          table.style.visibility = 'visible';
          table.style.opacity = '1';
        }
      }, 50);
    });
    

    function init(){ 
      // load data from IndexedDB into memory (IDB is now the default backend)
      loadAllFromIDB().then(()=>{
        tryMigrateFromIDB();
        atualizarSelectAnos();
        setTimeout(() => {
          const sel = document.getElementById('select-anos-receitas');
          if (sel && sel.value) { renderizarReceitasAno(sel.value); }
        }, 100);
      }).catch(()=>{
        // fallback: still try migrate and render
        tryMigrateFromIDB();
        atualizarSelectAnos();
        setTimeout(() => { const sel = document.getElementById('select-anos-receitas'); if (sel && sel.value) renderizarReceitasAno(sel.value); }, 100);
      });
    }
    init();

    // Ouve mudan√ßas vindas da p√°gina Importar
    window.addEventListener('storage', (e)=>{ 
      if(e.key === 'vendasResumo' || e.key === 'vendasResumo_last_update'){ 
        atualizarSelectAnos(); 
        const sel=document.getElementById('select-anos-receitas'); 
        if(sel && sel.value) {
          renderizarReceitasAno(sel.value); 
        }
      } 
    });

    // Fallback polling (mesma aba)
    setInterval(() => {
      const lastUpdate = localStorage.getItem('vendasResumo_last_update');
      if (lastUpdate && window.lastKnownUpdate !== lastUpdate) {
        window.lastKnownUpdate = lastUpdate;
        atualizarSelectAnos();
        const sel = document.getElementById('select-anos-receitas');
        if (sel && sel.value) {
          renderizarReceitasAno(sel.value);
        }
      }
    }, 1000);
    
    // Intercepta cliques no sidebar para anima√ß√£o sutil antes de navegar
    (function(){
      const links = document.querySelectorAll('aside nav a.sidebar-link');
      links.forEach(a=>{
        // apply immediate guard on mousedown/touchstart to avoid flicker
        a.addEventListener('mousedown', function(){ const asideEl = document.querySelector('aside.sidebar-collapsed'); if (asideEl) asideEl.classList.add('no-collapse'); });
        a.addEventListener('touchstart', function(){ const asideEl = document.querySelector('aside.sidebar-collapsed'); if (asideEl) asideEl.classList.add('no-collapse'); }, {passive:true});

        a.addEventListener('click', function(e){
          const href = a.getAttribute('href');
          if (!href || href.startsWith('#')) return;
          // se j√° estivermos na mesma rota, deixa o comportamento normal
          const current = location.pathname.split('/').pop();
          if (current === href) return; 
          e.preventDefault();
          const asideEl = document.querySelector('aside.sidebar-collapsed'); if (asideEl) { setTimeout(()=> asideEl.classList.remove('no-collapse'), 1200); }
          const main = document.querySelector('main') || document.querySelector('.main-content') || document.body;
          if (main) main.classList.add('page-exit');
          setTimeout(()=> { location.href = href; }, 260);
        });
      });
    })();

    // ===== Importer helpers & handlers (moved from importar.html, adapted) =====
    function parseNumber(v){
      if (v == null) return 0;
      let s = String(v).trim();
      if (s === '') return 0;
      // remove currency symbol and spaces
      s = s.replace(/R\$|\s/g,'');
      // if contains comma, assume Brazilian format '1.234,56' -> remove dots as thousands and replace comma with dot
      if (s.indexOf(',') !== -1){
        s = s.replace(/\./g,'').replace(',', '.');
      } else {
        // otherwise remove any non-digit except dot and minus
        s = s.replace(/[^0-9.\-]/g,'');
      }
      const n = parseFloat(s);
      return isNaN(n) ? 0 : n;
    }
    // Converte serial Excel para Date sem causar shift de dia por fuso hor√°rio.
    // Estrat√©gia: calcula a data em UTC e ent√£o cria um Date no hor√°rio local com ano/mes/dia correspondentes,
    // garantindo que a data de dia/m√™s/ano seja preservada independentemente do timezone do navegador.
    function excelDateToJSDate(serial){
      try{
        const serialNum = Number(serial);
        if (isNaN(serialNum)) return null;
        // base date: 1899-12-30 (Excel serial 1 = 1899-12-31, but offset 25569 maps to 1970-01-01)
        // calcula em milissegundos UTC
        const ms = Math.round((serialNum - 25569) * 86400 * 1000);
        const dUtc = new Date(ms);
        // extrai Y/M/D em UTC e cria Data no hor√°rio local com esses componentes (sem shift)
        const y = dUtc.getUTCFullYear();
        const m = dUtc.getUTCMonth();
        const day = dUtc.getUTCDate();
        return new Date(y, m, day);
      }catch(e){ return null; }
    }
    function parseDateToAnoMes(value){
      let anoMes = 'Indefinido';
      if (value == null) return { anoMes };
      if (typeof value === 'string'){
        const datePart = value.split(' ')[0].trim();
        if (datePart.includes('/')){
          const parts = datePart.split('/');
          if (parts.length >= 3){
            const mes = parts[1].padStart(2,'0');
            let ano = parts[2].split(' ')[0];
            if (ano.length === 2 && /^\d{2}$/.test(ano)){ const n = Number(ano); ano = n < 50 ? '20' + ano : '19' + ano; }
            anoMes = `${ano}/${mes}`; return { anoMes };
          }
        }
        if (datePart.includes('-')){
          const parts = datePart.split('-');
          if (parts.length === 3){
            if (parts[0].length === 4){ const ano = parts[0]; const mes = parts[1].padStart(2,'0'); anoMes = `${ano}/${mes}`; return { anoMes }; }
            if (parts[2].length === 4 || parts[2].length === 2){ let ano = parts[2]; if (ano.length === 2 && /^\d{2}$/.test(ano)){ const n = Number(ano); ano = n < 50 ? '20' + ano : '19' + ano; } const mes = parts[1].padStart(2,'0'); anoMes = `${ano}/${mes}`; return { anoMes }; }
          }
        }
  const parsed = Date.parse(value);
  if (!isNaN(parsed)){ const d = new Date(parsed); const mes = String(d.getMonth()+1).padStart(2,'0'); const ano = d.getFullYear(); anoMes = `${ano}/${mes}`; return { anoMes }; }
      }
      if (!isNaN(value)){
        const d = excelDateToJSDate(Number(value)); if (d && !isNaN(d.getTime())){ const mes = String(d.getMonth()+1).padStart(2,'0'); const ano = d.getFullYear(); anoMes = `${ano}/${mes}`; return { anoMes }; }
      }
      return { anoMes };
    }

    // Parse a value (string, Excel serial, ISO) into a JS Date if possible.
    function parseToJSDate(value){
      if (value == null) return null;
      // Excel serial number
      if (!isNaN(value) && value !== ''){
        try{ return excelDateToJSDate(Number(value)); }catch(e){}
      }
      if (typeof value === 'string'){
        const s = value.trim();
        // dd/mm/yyyy[ hh:mm[:ss]]
        const m1 = s.match(/^(\d{1,2})\/(\d{1,2})\/(\d{2,4})(?:[ T]+(\d{1,2}):(\d{1,2})(?::(\d{1,2}))?)?/);
        if (m1){
          const day = Number(m1[1]); const month = Number(m1[2]); let year = Number(m1[3]); if (year < 100) year += (year < 50 ? 2000 : 1900);
          const hour = m1[4] ? Number(m1[4]) : 0; const min = m1[5] ? Number(m1[5]) : 0; const sec = m1[6] ? Number(m1[6]) : 0;
          return new Date(year, month-1, day, hour, min, sec);
        }
        // yyyy/mm/dd or yyyy-mm-dd optionally with time
        const m2 = s.match(/^(\d{4})[\/-](\d{1,2})[\/-](\d{1,2})(?:[ T]+(\d{1,2}):(\d{1,2})(?::(\d{1,2}))?)?/);
        if (m2){
          const year = Number(m2[1]); const month = Number(m2[2]); const day = Number(m2[3]);
          const hour = m2[4] ? Number(m2[4]) : 0; const min = m2[5] ? Number(m2[5]) : 0; const sec = m2[6] ? Number(m2[6]) : 0;
          return new Date(year, month-1, day, hour, min, sec);
        }
        // yyyy-mm-dd or ISO parse
        const iso = Date.parse(s);
        if (!isNaN(iso)) return new Date(iso);
      }
      return null;
    }

    // Extrai data e hora de v√°rias representa√ß√µes (Excel serial, dd/mm/yyyy hh:mm, ISO, ou date+time em uma c√©lula).
    // Retorna { dateObj, dateStr: 'YYYY/MM/DD', timeStr: 'HH:MM:SS' }
    function extractDateTime(value){
      if (value == null) return { dateObj: null, dateStr: null, timeStr: null };
      // helper
      const pad = (n) => String(n).padStart(2,'0');
      // Excel serial (may include fractional part for time)
      if (!isNaN(value) && value !== ''){
        try{
          const serialNum = Number(value);
          const ms = Math.round((serialNum - 25569) * 86400 * 1000);
          const dUtc = new Date(ms);
          const y = dUtc.getUTCFullYear(); const m = dUtc.getUTCMonth()+1; const day = dUtc.getUTCDate();
          const h = dUtc.getUTCHours(); const min = dUtc.getUTCMinutes(); const sec = dUtc.getUTCSeconds();
          const dateStr = `${y}/${pad(m)}/${pad(day)}`;
          const timeStr = `${pad(h)}:${pad(min)}:${pad(sec)}`;
          const dateObj = new Date(y, m-1, day, h, min, sec);
          return { dateObj, dateStr, timeStr };
        }catch(e){ /* fallthrough */ }
      }
      if (typeof value === 'string'){
        const s = value.trim();
        // if contains space between date and time, try split
        const parts = s.split(/\s+/);
        if (parts.length >= 2){
          const datePart = parts[0]; const timePart = parts.slice(1).join(' ');
          // try parse datePart + timePart together
          const dt = parseToJSDate(datePart + ' ' + timePart) || parseToJSDate(s);
          if (dt && !isNaN(dt.getTime())){
            const y = dt.getFullYear(); const m = dt.getMonth()+1; const day = dt.getDate();
            const h = dt.getHours(); const min = dt.getMinutes(); const sec = dt.getSeconds();
            return { dateObj: dt, dateStr: `${y}/${pad(m)}/${pad(day)}`, timeStr: `${pad(h)}:${pad(min)}:${pad(sec)}` };
          }
        }
        // try dd/mm/yyyy with optional time
        const m1 = s.match(/^(\d{1,2})\/(\d{1,2})\/(\d{2,4})(?:[ T]+(\d{1,2}):(\d{1,2})(?::(\d{1,2}))?)?/);
        if (m1){
          const day = Number(m1[1]); const month = Number(m1[2]); let year = Number(m1[3]); if (year < 100) year += (year < 50 ? 2000 : 1900);
          const hour = m1[4] ? Number(m1[4]) : 0; const min = m1[5] ? Number(m1[5]) : 0; const sec = m1[6] ? Number(m1[6]) : 0;
          const dateObj = new Date(year, month-1, day, hour, min, sec);
          return { dateObj, dateStr: `${year}/${pad(month)}/${pad(day)}`, timeStr: `${pad(hour)}:${pad(min)}:${pad(sec)}` };
        }
        // yyyy-mm-dd or ISO
        const iso = Date.parse(s);
        if (!isNaN(iso)){
          const dt = new Date(iso);
          const y = dt.getFullYear(); const m = dt.getMonth()+1; const day = dt.getDate();
          const h = dt.getHours(); const min = dt.getMinutes(); const sec = dt.getSeconds();
          return { dateObj: dt, dateStr: `${y}/${pad(m)}/${pad(day)}`, timeStr: `${pad(h)}:${pad(min)}:${pad(sec)}` };
        }
      }
      return { dateObj: null, dateStr: null, timeStr: null };
    }

    // Normaliza um objeto de venda detalhada para o formato can√¥nico usado pela aplica√ß√£o.
    // Garante campos: date (YYYY/MM/DD), time (HH:MM:SS), ano, mes, dia (strings), anoMes (YYYY/MM),
    // valorBruto, mdr, valorLiquido (Number), source, tipoPagamento, dateMs (ms since epoch) e id determin√≠stico.
    function normalizeVendaDetalhada(raw){
      try{
        if(!raw || typeof raw !== 'object') return null;
        const pad = (n) => String(n).padStart(2,'0');
        // prefer explicit date/time fields if present
        let dateStr = raw.date || null;
        let timeStr = raw.time || null;
        let dateObj = null;
        // Attempt robust extraction from various possible raw inputs.
        //  - handle combined cells with two numeric tokens like "45688 25569.83" (take first >=40000 as excel serial)
        //  - handle time field that actually contains an excel serial
        //  - handle millisecond/second timestamps
        // If dateStr exists but contains multiple tokens (e.g. '45688 25569.83'), try to extract an Excel serial token
        if(dateStr && typeof dateStr === 'string'){
          const parts = dateStr.split(/\s+/).filter(Boolean);
          if(parts.length > 1){
            const excelCandidate = parts.find(p => !isNaN(p) && Number(p) >= 40000 && Number(p) < 60000);
            if(excelCandidate){
              const serialNum = Number(excelCandidate);
              const baseDate = excelDateToJSDate(serialNum);
              if(baseDate && !isNaN(baseDate.getTime())){
                const fracStr = parts.find(p => p !== excelCandidate && !isNaN(p));
                let parsed = baseDate;
                if(fracStr){
                  const frac = Number(fracStr) - Math.floor(Number(fracStr));
                  if(frac > 0){
                    const addMs = Math.round(frac * 24 * 60 * 60 * 1000);
                    parsed = new Date(baseDate.getTime() + addMs);
                  }
                }
                dateObj = parsed;
                dateStr = `${parsed.getFullYear()}/${pad(parsed.getMonth()+1)}/${pad(parsed.getDate())}`;
                timeStr = timeStr || `${String(parsed.getHours()).padStart(2,'0')}:${String(parsed.getMinutes()).padStart(2,'0')}:${String(parsed.getSeconds()).padStart(2,'0')}`;
              }
            }
          }
        }
        if(!dateStr){ // try extract from combined or other fields
          const combined = raw.date || raw.time || raw.data || raw.datetime || null;
          // if combined is a string with two numeric tokens, try to pick the token that looks like an Excel serial
          if(combined && typeof combined === 'string'){
            const parts = combined.split(/\s+/).filter(Boolean);
            const excelCandidate = parts.find(p => !isNaN(p) && Number(p) >= 40000 && Number(p) < 60000);
            if(excelCandidate){
              // parse serial and also consider fractional part as time
              const serialNum = Number(excelCandidate);
              const baseDate = excelDateToJSDate(serialNum);
              if(baseDate && !isNaN(baseDate.getTime())){
                const frac = serialNum - Math.floor(serialNum);
                let parsed = baseDate;
                if(frac > 0){
                  const addMs = Math.round(frac * 24 * 60 * 60 * 1000);
                  parsed = new Date(baseDate.getTime() + addMs);
                }
                dateObj = parsed;
                dateStr = `${parsed.getFullYear()}/${pad(parsed.getMonth()+1)}/${pad(parsed.getDate())}`;
                timeStr = timeStr || `${String(parsed.getHours()).padStart(2,'0')}:${String(parsed.getMinutes()).padStart(2,'0')}:${String(parsed.getSeconds()).padStart(2,'0')}`;
              }
            }
          }
          // if still not found, try generic extractor (handles dd/mm/yyyy hh:mm or ISO)
          if(!dateObj){
            const ex = extractDateTime(combined);
            if(ex){ dateStr = dateStr || ex.dateStr; timeStr = timeStr || ex.timeStr; dateObj = dateObj || ex.dateObj; }
          }
        }
        if(!dateObj && dateStr){ dateObj = parseToJSDate(dateStr) || (new Date(dateStr)); }
        if(!dateStr && dateObj && !isNaN(dateObj.getTime())){ dateStr = `${dateObj.getFullYear()}/${pad(dateObj.getMonth()+1)}/${pad(dateObj.getDate())}`; }
        if(!timeStr && dateObj && !isNaN(dateObj.getTime())){ const hh = String(dateObj.getHours()).padStart(2,'0'); const mm = String(dateObj.getMinutes()).padStart(2,'0'); const ss = String(dateObj.getSeconds()).padStart(2,'0'); timeStr = `${hh}:${mm}:${ss}`; }

        if(!dateObj){
          // raw.date might be a plain numeric serial (or string containing numeric). Try parse.
          const maybe = raw.date != null ? String(raw.date).trim() : '';
          if(maybe && !isNaN(maybe)){
            const n = Number(maybe);
            // Excel serial range heuristic
            if(n >= 40000 && n < 60000){
              const d = excelDateToJSDate(n);
              if(d && !isNaN(d.getTime())){
                dateObj = d;
                const hh = String(d.getHours()).padStart(2,'0'); const mm = String(d.getMinutes()).padStart(2,'0'); const ss = String(d.getSeconds()).padStart(2,'0');
                dateStr = `${d.getFullYear()}/${pad(d.getMonth()+1)}/${pad(d.getDate())}`;
                timeStr = timeStr || `${hh}:${mm}:${ss}`;
              }
            }
            // also try raw.time if it contains a serial
            if(!dateObj && raw.time != null && String(raw.time).trim() && !isNaN(String(raw.time).trim())){
              const tn = Number(String(raw.time).trim());
              if(tn >= 40000 && tn < 60000){
                const d = excelDateToJSDate(tn);
                if(d && !isNaN(d.getTime())){
                  dateObj = d;
                  const hh = String(d.getHours()).padStart(2,'0'); const mm = String(d.getMinutes()).padStart(2,'0'); const ss = String(d.getSeconds()).padStart(2,'0');
                  dateStr = `${d.getFullYear()}/${pad(d.getMonth()+1)}/${pad(d.getDate())}`;
                  timeStr = timeStr || `${hh}:${mm}:${ss}`;
                }
              }
            }
          }
          // if still not parsed, try timestamps (ms or seconds)
          if(!dateObj){
            const cand = (raw.date || raw.time || '').toString().trim();
            const maybeMs = Number(cand);
            if(!isNaN(maybeMs) && maybeMs > 1e11){ // ms timestamp
              const d = new Date(maybeMs);
              if(d && !isNaN(d.getTime())){ dateObj = d; dateStr = `${d.getFullYear()}/${pad(d.getMonth()+1)}/${pad(d.getDate())}`; timeStr = timeStr || `${String(d.getHours()).padStart(2,'0')}:${String(d.getMinutes()).padStart(2,'0')}:${String(d.getSeconds()).padStart(2,'0')}`; }
            } else if(!isNaN(maybeMs) && maybeMs > 1e9 && maybeMs < 1e11){ // seconds
              const d = new Date(Math.round(maybeMs) * 1000);
              if(d && !isNaN(d.getTime())){ dateObj = d; dateStr = `${d.getFullYear()}/${pad(d.getMonth()+1)}/${pad(d.getDate())}`; timeStr = timeStr || `${String(d.getHours()).padStart(2,'0')}:${String(d.getMinutes()).padStart(2,'0')}:${String(d.getSeconds()).padStart(2,'0')}`; }
            }
          }
        }

        // finalize date/time fallback
        let ano='', mes='', dia='', anoMes=''; let dateMs = null;
        if(dateStr){ const parts = String(dateStr).split('/'); if(parts.length>=3){ ano = parts[0]; mes = String(parts[1]).padStart(2,'0'); dia = String(parts[2]).padStart(2,'0'); anoMes = `${ano}/${mes}`; } }
        if(!dateMs && dateObj && !isNaN(dateObj.getTime())) dateMs = dateObj.getTime();

        // amounts
        const valorBruto = (raw.valorBruto != null ? Number(raw.valorBruto) : (raw.value != null ? Number(raw.value) : Number(raw.valor || 0))) || 0;
        const mdr = (raw.mdr != null ? Number(raw.mdr) : (raw.valorMdr != null ? Number(raw.valorMdr) : Number(raw.valorMDR || 0))) || 0;
        const valorLiquido = (raw.valorLiquido != null ? Number(raw.valorLiquido) : (raw.valorLiquidoRaw != null ? Number(raw.valorLiquidoRaw) : (valorBruto - mdr))) || (valorBruto - mdr);

        // canonicalize source string: prefer 'pix' or 'cartao' (lowercase)
        let rawSourceStr = (raw.source || raw.fonte || '').toString().trim().toLowerCase();
        let source = 'cartao';
        if(rawSourceStr){
          if(rawSourceStr.indexOf('pix') !== -1) source = 'pix';
          else if(rawSourceStr.indexOf('cart') !== -1 || rawSourceStr.indexOf('cred') !== -1 || rawSourceStr.indexOf('deb') !== -1) source = 'cartao';
          else source = rawSourceStr; // keep lowercase fallback (e.g., custom tags)
        } else {
          // fallback: infer from tipoPagamento when possible
          const tp = String(raw.tipoPagamento || '').toLowerCase();
          if(tp.indexOf('pix') !== -1) source = 'pix';
          else source = 'cartao';
        }
        const tipoPagamento = raw.tipoPagamento || raw.tipo || raw.modalidade || '';

        // ensure time string is zero-padded to HH:MM:SS
        // If timeStr is a numeric Excel-like serial (e.g. 25569.8849...), extract fractional part as time of day.
        if((typeof timeStr === 'number') || (typeof timeStr === 'string' && /^\d+(?:\.\d+)?$/.test(timeStr))){
          const n = Number(timeStr);
          if(!isNaN(n)){
            const frac = n - Math.floor(n);
            if(frac > 0){
              const totalSec = Math.round(frac * 24 * 60 * 60);
              const hh = Math.floor(totalSec / 3600);
              const mm = Math.floor((totalSec % 3600) / 60);
              const ss = totalSec % 60;
              timeStr = `${String(hh).padStart(2,'0')}:${String(mm).padStart(2,'0')}:${String(ss).padStart(2,'0')}`;
            } else if(n > 1e11){
              // maybe it's a ms timestamp
              try{ const d = new Date(Math.round(n)); if(!isNaN(d.getTime())){ timeStr = `${String(d.getHours()).padStart(2,'0')}:${String(d.getMinutes()).padStart(2,'0')}:${String(d.getSeconds()).padStart(2,'0')}`; } }catch(e){}
            }
          }
        }
        let timeFinal = timeStr || '';
        if(timeFinal && /^\\d{1,2}:\d{1,2}$/.test(timeFinal)) timeFinal = timeFinal + ':00';
        if(timeFinal){ const m = String(timeFinal).match(/^(\d{1,2}):(\d{1,2}):(\d{1,2})$/); if(m){ timeFinal = `${m[1].padStart(2,'0')}:${m[2].padStart(2,'0')}:${m[3].padStart(2,'0')}`; } }

        const dateField = dateStr || '';
        const timeField = timeFinal || '';
        const id = `${dateField} ${timeField}||${Number(valorBruto||0).toFixed(2)}||${source}||${String(tipoPagamento||'')}`;

        return {
          date: dateField,
          time: timeField,
          ano: String(ano||''),
          mes: String(mes||''),
          dia: String(dia||''),
          anoMes: anoMes || '',
          dateMs: dateMs,
          valorBruto: Number(valorBruto||0),
          mdr: Number(mdr||0),
          valorLiquido: Number(valorLiquido||0),
          source: source,
          tipoPagamento: String(tipoPagamento||''),
          id: id
        };
      }catch(e){ return null; }
    }

    // Detailed transactions storage (keeps per-row data to allow weekday/month aggregations)
    // Support chunked persistence for large datasets to avoid localStorage quota failures.
    // carregarVendasDetalhadas will read either the legacy single key or assemble from chunk keys.
    function carregarVendasDetalhadas(){
      try {
        const chunksMeta = localStorage.getItem('vendasDetalhadas_chunks');
        if(chunksMeta){
          try{
            const keys = JSON.parse(chunksMeta) || [];
            let out = [];
            for(const k of keys){
              try{ const part = JSON.parse(localStorage.getItem(k) || '[]'); if(Array.isArray(part)) out = out.concat(part); }catch(e){}
            }
            // detect compact format (short keys) and expand to canonical shape if needed
            try{
              if(out.length>0){
                const first = out[0];
                // object-compact format
                if(first && (first.d !== undefined || first.v !== undefined)){
                  const expanded = out.map(it => ({
                    date: it.d || '',
                    time: it.t || '',
                    dateMs: (it.ms != null) ? Number(it.ms) : null,
                    valorBruto: (it.v != null) ? (Number(it.v)/100) : 0,
                    mdr: (it.m != null) ? (Number(it.m)/100) : 0,
                    source: it.s || '',
                    tipoPagamento: it.p || '',
                    id: it.id || ''
                  }));
                  return expanded;
                }
                // ultra-compact array format: [d,t,v,s,p,m] (d=date, t=time, v=cents, s=source, p=tipo, m=mdr cents)
                if(Array.isArray(first)){
                  const expanded = out.map(arr => ({
                    date: arr[0] || '',
                    time: arr[1] || '',
                    dateMs: null,
                    valorBruto: (arr[2] != null) ? Number(arr[2])/100 : 0,
                    source: arr[3] || '',
                    tipoPagamento: arr[4] || '',
                    mdr: (arr[5] != null) ? Number(arr[5])/100 : 0,
                    id: `${arr[0]||''} ${arr[1]||''}||${((arr[2]!=null)?(Number(arr[2])/100).toFixed(2):'0.00')}||${arr[3]||''}||${arr[4]||''}`
                  }));
                  return expanded;
                }
              }
            }catch(e){ /* ignore expansion errors, return raw */ }
            return out;
          }catch(e){ /* fall through to legacy */ }
        }
        // legacy single-key
        const raw = JSON.parse(localStorage.getItem('vendasDetalhadas') || '[]') || [];
        // detect compact single-key
        try{
          if(Array.isArray(raw) && raw.length>0){
            const first = raw[0];
            if(first && (first.d !== undefined || first.v !== undefined)){
              return raw.map(it => ({ date: it.d || '', time: it.t || '', dateMs: (it.ms != null)?Number(it.ms):null, valorBruto: (it.v!=null)?(Number(it.v)/100):0, mdr: (it.m!=null)?(Number(it.m)/100):0, source: it.s||'', tipoPagamento: it.p||'', id: it.id||'' }));
            }
            if(Array.isArray(first)){
              return raw.map(arr => ({ date: arr[0] || '', time: arr[1] || '', dateMs: null, valorBruto: (arr[2] != null) ? Number(arr[2])/100 : 0, source: arr[3] || '', tipoPagamento: arr[4] || '', mdr: (arr[5] != null) ? Number(arr[5])/100 : 0, id: `${arr[0]||''} ${arr[1]||''}||${((arr[2]!=null)?(Number(arr[2])/100).toFixed(2):'0.00')}||${arr[3]||''}||${arr[4]||''}` }));
            }
          }
        }catch(e){}
        // If legacy localStorage is empty but we have an in-memory fallback (set when IDB was used), return it
        try{
          if((!raw || (Array.isArray(raw) && raw.length===0)) && window._vendasDetalhadas_inMemory && Array.isArray(window._vendasDetalhadas_inMemory)){
            // expand in-memory normalized records to canonical shape if needed
            try{
              const mem = window._vendasDetalhadas_inMemory || [];
              const mapped = mem.map(function(x){
                try{
                  if(x && x.date) return x;
                  if(Array.isArray(x)){
                    const id = `${x[0]||''} ${x[1]||''}||${((x[2]!=null)?(Number(x[2])/100).toFixed(2):'0.00')}||${x[3]||''}||${x[4]||''}`;
                    return { date: x[0]||'', time: x[1]||'', dateMs: null, valorBruto: (x[2]!=null)?(Number(x[2])/100):0, source: x[3]||'', tipoPagamento: x[4]||'', mdr: (x[5]!=null)?(Number(x[5])/100):0, id };
                  }
                  return x;
                }catch(e){ return x; }
              });
              return mapped;
            }catch(e){}
          }
        }catch(e){}
        return raw;
      } catch(e){ return []; }
    }

    // Async loader that reads from IndexedDB first, expands compact formats, and returns canonical array
    async function carregarVendasDetalhadasAsync(){
      try{
        // prefer in-memory cache populated at boot
        if(window._vendasDetalhadas_inMemory && Array.isArray(window._vendasDetalhadas_inMemory)) return window._vendasDetalhadas_inMemory.slice();
        // try IDB
        try{
          const data = await idbGet('vendasDetalhadas');
          if(data && Array.isArray(data.data)){
            const arr = data.data;
            // detect compact object or ultra-array
            if(arr.length>0){
              const first = arr[0];
              if(first && (first.d !== undefined || first.v !== undefined)){
                return arr.map(it => ({ date: it.d || '', time: it.t || '', dateMs: (it.ms != null)?Number(it.ms):null, valorBruto: (it.v!=null)?(Number(it.v)/100):0, mdr: (it.m!=null)?(Number(it.m)/100):0, source: it.s||'', tipoPagamento: it.p||'', id: it.id||'' }));
              }
              if(Array.isArray(first)){
                return arr.map(a => ({ date: a[0]||'', time: a[1]||'', dateMs: null, valorBruto: (a[2]!=null)?(Number(a[2])/100):0, mdr: (a[5]!=null)?(Number(a[5])/100):0, source: a[3]||'', tipoPagamento: a[4]||'', id: `${a[0]||''} ${a[1]||''}||${((a[2]!=null)?(Number(a[2])/100).toFixed(2):'0.00')}||${a[3]||''}||${a[4]||''}` }));
              }
            }
            return [];
          }
        }catch(e){ /* ignore idb read errors */ }
        // fallback to legacy localStorage loader
        return carregarVendasDetalhadas();
      }catch(err){ console.warn('carregarVendasDetalhadasAsync falhou', err); return []; }
    }

    // salvarVendasDetalhadas will attempt to write the full array to a single key; if that fails
    // it will split the array into smaller chunks and persist each chunk under vendasDetalhadas_chunk_<i>
    // and store the chunk keys list in 'vendasDetalhadas_chunks'. It also removes old chunk keys when
    // saving in legacy single-key mode.
    async function salvarVendasDetalhadas(arr){
      try{
        if(!Array.isArray(arr)) arr = [];
        const LEGACY_KEY = 'vendasDetalhadas';
        const CHUNKS_META_KEY = 'vendasDetalhadas_chunks';

        // Create a compact representation to reduce JSON size: short keys and integer cents for values
        const compact = arr.map(x => {
          try{
            return {
              d: x.date || '',
              t: x.time || '',
              ms: (x.dateMs != null) ? Number(x.dateMs) : null,
              v: Math.round((Number(x.valorBruto || x.value || x.valor || x.receitaBruta || 0) || 0) * 100),
              s: x.source || '',
              p: x.tipoPagamento || '',
              m: (x.mdr != null) ? Math.round(Number(x.mdr || 0) * 100) : 0,
              id: x.id || ''
            };
          }catch(e){ return {d:'',t:'',ms:null,v:0,s:'',p:'',m:0,id:''}; }
        });

  // Persist compact copy to IndexedDB asynchronously (IDB is the default backend)
  try{ idbPut('vendasDetalhadas', { format: 'compact', data: compact }).then(()=>{ try{ localStorage.setItem('vendasDetalhadas_idb','1'); }catch(e){} }).catch(()=>{}); }catch(e){}
  // update in-memory canonical cache so synchronous loaders use IDB-backed data
  try{ window._vendasDetalhadas_inMemory = Array.isArray(arr) ? arr.slice() : null; }catch(e){}

        // Try to write whole compact array to single key first
        try{
          localStorage.setItem(LEGACY_KEY, JSON.stringify(compact));
          // cleanup old chunk keys if exist
          try{ const prev = localStorage.getItem(CHUNKS_META_KEY); if(prev){ const keys = JSON.parse(prev) || []; for(const k of keys) try{ localStorage.removeItem(k); }catch(e){} localStorage.removeItem(CHUNKS_META_KEY); } }catch(e){}
          // also persist to IDB asynchronously
          try{ await idbPut('vendasDetalhadas', { format:'compact', data: compact }); try{ localStorage.setItem('vendasDetalhadas_idb','1'); }catch(e){} }catch(e){}
          // update in-memory cache
          try{ window._vendasDetalhadas_inMemory = Array.isArray(arr) ? arr.slice() : null; }catch(e){}
          return true;
        }catch(e){ /* fallthrough to chunked persistence */ }

        // chunked persistence with adaptive chunk size
        try{
          // remove previous chunks if any
          try{ const prev = localStorage.getItem(CHUNKS_META_KEY); if(prev){ const keys = JSON.parse(prev) || []; for(const k of keys) try{ localStorage.removeItem(k); }catch(e){} } }catch(e){}

          // Try several strategies, progressively more compact and smaller chunk sizes.
          const strategies = [
            { type: 'object-compact', data: compact, initialChunk: 1000, minChunk: 50 },
          ];

          let wrote = false;
          for(const strat of strategies){
            let CHUNK_SIZE = strat.initialChunk;
            while(CHUNK_SIZE >= strat.minChunk){
              try{
                const chunkKeys = [];
                for(let i=0;i<strat.data.length;i+=CHUNK_SIZE){
                  const slice = strat.data.slice(i, i+CHUNK_SIZE);
                  const key = `vendasDetalhadas_chunk_${Math.floor(i/CHUNK_SIZE)}`;
                  localStorage.setItem(key, JSON.stringify(slice));
                  chunkKeys.push(key);
                }
                localStorage.setItem(CHUNKS_META_KEY, JSON.stringify(chunkKeys));
                try{ localStorage.removeItem(LEGACY_KEY); }catch(e){}
                // mark format used
                try{ localStorage.setItem('vendasDetalhadas_format','compact'); }catch(e){}
                wrote = true; break;
              }catch(e){
                // clear any keys written in this attempt
                try{ const keys = JSON.parse(localStorage.getItem(CHUNKS_META_KEY) || '[]'); for(const k of keys) try{ localStorage.removeItem(k); }catch(_){}}catch(_){ }
                CHUNK_SIZE = Math.floor(CHUNK_SIZE / 2);
              }
            }
            if(wrote) break;
          }

          if(wrote) return true;

          // As a last resort, attempt an ultra-compact representation (arrays) which has much lower JSON overhead.
          try{
            const ultra = compact.map(it => {
              // [date, time, valorCents, source, tipo, mdrCents]
              return [ it.d || '', it.t || '', Number(it.v || 0), it.s || '', it.p || '', Number(it.m || 0) ];
            });
            // try single-key first
            try{ localStorage.setItem(LEGACY_KEY, JSON.stringify(ultra)); localStorage.setItem('vendasDetalhadas_format','ultra'); try{ localStorage.removeItem(CHUNKS_META_KEY); }catch(e){} return true; }catch(e){}
            // chunk ultra with small sizes
            let CHUNK = 200;
            while(CHUNK >= 20){
              try{
                const chunkKeys = [];
                for(let i=0;i<ultra.length;i+=CHUNK){
                  const slice = ultra.slice(i,i+CHUNK);
                  const key = 'vendasDetalhadas_chunk_' + Math.floor(i/CHUNK);
                  localStorage.setItem(key, JSON.stringify(slice));
                  chunkKeys.push(key);
                }
                localStorage.setItem(CHUNKS_META_KEY, JSON.stringify(chunkKeys));
                try{ localStorage.removeItem(LEGACY_KEY); }catch(e){}
                try{ localStorage.setItem('vendasDetalhadas_format','ultra'); }catch(e){}
                return true;
              }catch(e){
                try{
                  const keys = JSON.parse(localStorage.getItem(CHUNKS_META_KEY) || '[]');
                  for(const k of keys){ try{ localStorage.removeItem(k); }catch(_){}}
                }catch(_){ }
                CHUNK = Math.floor(CHUNK/2);
              }
            }
          }catch(e){ /* fallthrough */ }

          // If all localStorage strategies failed, fallback to IndexedDB (awaited) and keep in-memory copy
          try{
            try{ window._vendasDetalhadas_inMemory = Array.isArray(arr) ? arr.slice() : null; }catch(e){}
            await idbPut('vendasDetalhadas', { format: 'compact', data: compact });
            try{ localStorage.setItem('vendasDetalhadas_idb','1'); }catch(e){}
            return true;
          }catch(err){ console.error('Erro ao salvar em IndexedDB', err); return false; }
        }catch(e){ console.error('Erro ao salvar vendasDetalhadas em chunks', e); return false; }
      }catch(err){ console.error('salvarVendasDetalhadas falhou', err); return false; }
    }
    async function addVendaDetalhada(tx){
      try{
        const arr = await carregarVendasDetalhadasAsync();
        const existing = new Set(arr.map(x => x && x.id ? x.id : `${x.date||''} ${x.time||''}||${Number(x.valorBruto||0).toFixed(2)}||${x.source||''}||${x.tipoPagamento||''}`));
        const normalized = normalizeVendaDetalhada(tx);
        if(!normalized) return false;
        // if exact id exists, skip
        if(existing.has(normalized.id)) return false;
        // if not, but there is an existing placeholder (no date/dateMs) with same signature (valor/source/tipo),
        // replace it with the normalized record that includes date/time
        if(normalized && (normalized.date || normalized.dateMs)){
          const signatureSuffix = `||${Number(normalized.valorBruto||0).toFixed(2)}||${normalized.source}||${normalized.tipoPagamento}`;
          const idx = arr.findIndex(x => x && x.id && String(x.id).endsWith(signatureSuffix) && (!x.date || !x.dateMs));
          if(idx >= 0){ arr[idx] = normalized; await salvarVendasDetalhadas(arr); return true; }
        }
        arr.push(normalized);
        await salvarVendasDetalhadas(arr);
        return true;
      }catch(e){ console.warn('Erro ao salvar venda detalhada', e); return false; }
    }

    // Adiciona m√∫ltiplas vendas detalhadas em lote (mais eficiente que chamar addVendaDetalhada por linha)
    async function addVendasDetalhadasBulk(txs){
      try{
        if(!Array.isArray(txs) || txs.length===0) return 0;
        const arr = await carregarVendasDetalhadasAsync();
        const existing = new Set(arr.map(x => x && x.id ? x.id : `${x.date||''} ${x.time||''}||${Number(x.valorBruto||0).toFixed(2)}||${x.source||''}||${x.tipoPagamento||''}`));
        let added = 0;
        let replaced = 0;
        for(const tx of txs){
          const normalized = normalizeVendaDetalhada(tx);
          if(!normalized) continue;
          if(existing.has(normalized.id)) continue;
          // attempt replace: if normalized has date info and there's an existing placeholder (same valor/source/tipo) without date, replace it
          const signatureSuffix = `||${Number(normalized.valorBruto||0).toFixed(2)}||${normalized.source}||${normalized.tipoPagamento}`;
          if(normalized && (normalized.date || normalized.dateMs)){
            const idx = arr.findIndex(x => x && x.id && String(x.id).endsWith(signatureSuffix) && (!x.date || !x.dateMs));
            if(idx >= 0){ arr[idx] = normalized; existing.add(normalized.id); replaced++; continue; }
          }
          arr.push(normalized);
          existing.add(normalized.id);
          added++;
        }
        if(added>0 || replaced>0) await salvarVendasDetalhadas(arr);
        if(replaced>0) console.info('[addVendasDetalhadasBulk] replaced placeholders:', replaced);
        return added + replaced;
      }catch(e){ console.warn('Erro em addVendasDetalhadasBulk', e); return 0; }
    }

    // remove duplicates in vendasDetalhadas by id (or by computed signature) and persist unique list
    function dedupeVendasDetalhadas(){
      try{
        const arr = carregarVendasDetalhadas();
        const map = new Map();
        for (const x of arr){
          const nx = normalizeVendaDetalhada(x) || x;
          const key = nx && nx.id ? nx.id : `${nx.date||''} ${nx.time||''}||${Number(nx.valorBruto||0).toFixed(2)}||${nx.source||''}||${nx.tipoPagamento||''}`;
          if (!map.has(key)) map.set(key, {...nx, id: key});
        }
        const unique = Array.from(map.values());
        salvarVendasDetalhadas(unique);
        return unique.length;
      }catch(e){ return 0; }
    }

    // Reconstr√≥i vendasResumoDia a partir de vendasDetalhadas (idempotente)
    function rebuildDailyFromDetalhadas(){
      try{
        dedupeVendasDetalhadas();
        const detalhes = carregarVendasDetalhadas();
        const map = new Map();
        for(const tx of detalhes){
          if(!tx) continue;
          // tx.date should be 'YYYY/MM/DD' after normalization but try parse robustly
          const d = parseToJSDate(tx.date) || (tx.dateMs ? new Date(Number(tx.dateMs)) : null) || (tx.date ? new Date(tx.date) : null);
          if(!d || isNaN(d.getTime())) continue;
          const y = d.getFullYear(); const m = String(d.getMonth()+1).padStart(2,'0'); const day = String(d.getDate()).padStart(2,'0');
          const anoMesDia = `${y}/${m}/${day}`;
          const anoMes = `${y}/${m}`;
          const source = tx.source || '';
          const tipoPagamento = tx.tipoPagamento || '';
          const key = `${anoMesDia}||${source}||${tipoPagamento}`;
          const valor = Number(tx.valorBruto || 0) || 0;
          const mdrVal = Number(tx.mdr || 0) || 0;
          if(!map.has(key)) map.set(key, { anoMesDia, anoMes, source, tipoPagamento, receitaBruta:0, mdr:0, receitaLiquida:0 });
          const obj = map.get(key);
          obj.receitaBruta = (Number(obj.receitaBruta)||0) + valor;
          obj.mdr = (Number(obj.mdr)||0) + mdrVal;
          obj.receitaLiquida = obj.receitaBruta - obj.mdr;
          map.set(key, obj);
        }
        const daily = Array.from(map.values());
        salvarVendasResumoDia(daily);
        // atualizar resumo mensal tamb√©m
        computeMonthlyResumoFromDaily();
        return daily;
      }catch(e){ console.warn('Erro em rebuildDailyFromDetalhadas', e); return []; }
    }

    // Remove vendasDetalhadas correspondentes √†s chaves de vendasResumo (formato das chaves: 'YYYY/MM__source__tipo')
    function removerVendasDetalhadasPorVendasResumoKeys(keys){
      try{
        if(!Array.isArray(keys) || keys.length===0) return;
        const detalhes = carregarVendasDetalhadas();
        const parsedKeys = keys.map(k => {
          const parts = String(k||'').split('__');
          return { anoMes: parts[0]||'', source: parts[1]||'', tipo: parts[2]||'' };
        });
        const kept = detalhes.filter(tx => {
          try{
            const d = parseToJSDate(tx.date) || new Date(tx.date || '');
            if(!d || isNaN(d.getTime())) return true; // keep if cannot parse date
            const ano = d.getFullYear(); const mes = String(d.getMonth()+1).padStart(2,'0');
            const txAnoMes = `${ano}/${mes}`;
            const txSource = tx.source || '';
            const txTipo = tx.tipoPagamento || '';
            // if any parsedKey matches this transaction, remove it (i.e., return false)
            for(const pk of parsedKeys){
              if(pk.anoMes && pk.anoMes === txAnoMes && (pk.source === '' || pk.source === txSource) && (pk.tipo === '' || pk.tipo === txTipo)){
                return false;
              }
            }
            return true;
          }catch(e){ return true; }
        });
        salvarVendasDetalhadas(kept);
        // rebuild daily/monthly from remaining detalhes
        try{ rebuildDailyFromDetalhadas(); }catch(e){}
        try{ computeWeekdaySumsPerMonth(); }catch(e){}
      }catch(err){ console.warn('Erro ao remover vendas detalhadas por chaves', err); }
    }

    // Compute sums by weekday (0=Sunday..6=Saturday) grouped per month (YYYY/MM)
    function computeWeekdaySumsPerMonth(){
      // ensure we don't have duplicates before computing
      try{ dedupeVendasDetalhadas(); }catch(e){}
      const all = carregarVendasDetalhadas();
      const out = {};
      for (const t of all){
        // t.date should be ISO or parsable
        const d = t && t.date ? parseToJSDate(t.date) || (t.dateMs ? new Date(Number(t.dateMs)) : new Date(t.date)) : (t.dateMs ? new Date(Number(t.dateMs)) : null);
        if (!d || isNaN(d.getTime())) continue;
        const ano = d.getFullYear(); const mes = String(d.getMonth()+1).padStart(2,'0');
        const key = `${ano}/${mes}`;
        if (!out[key]) out[key] = { '0':0,'1':0,'2':0,'3':0,'4':0,'5':0,'6':0 };
        const wd = String(d.getDay());
        const v = Number(t.valorBruto || t.value || t.valor || 0) || 0;
        out[key][wd] = (Number(out[key][wd]) || 0) + v;
      }
      try{ localStorage.setItem('vendas_por_dia_semana', JSON.stringify(out)); }catch(e){ }
      return out;
    }

    // Retorna o nome do dia da semana em portugu√™s a partir de uma Date ou string de data
    function getDiaSemana(dateInput){
      try{
        let d = null;
        if (!dateInput) return null;
        if (dateInput instanceof Date) d = dateInput;
        else d = parseToJSDate(String(dateInput)) || new Date(String(dateInput));
        if (!d || isNaN(d.getTime())) return null;
        const nomes = ['domingo','segunda','ter√ßa','quarta','quinta','sexta','s√°bado'];
        return nomes[d.getDay()];
      }catch(e){ return null; }
    }

    // Agrega vendas por dia da semana para um m√™s especificado (anoMes no formato 'YYYY/MM')
    // Retorna objeto com chaves: domingo, segunda, ter√ßa, quarta, quinta, sexta, s√°bado
    function getSomaSemanalPorMes(anoMes){
      const zeroObj = { 'domingo':0,'segunda':0,'ter√ßa':0,'quarta':0,'quinta':0,'sexta':0,'s√°bado':0 };
      if(!anoMes) return zeroObj;
      try{
        // Prefer aggregating from vendasResumoDia (agregados por dia) because
        // essa fonte cont√©m os valores que aparecem na tabela superior (vendasResumo).
        // Dessa forma garantimos que a soma semanal ser√° consistente com a tabela.
        const daily = carregarVendasResumoDia() || [];
        const out = { ...zeroObj };
        for (const d of daily){
          try{
            if (!d || !d.anoMesDia) continue;
            // d.anoMes is 'YYYY/MM'
            if (String(d.anoMes) !== String(anoMes)) continue;
            const parts = String(d.anoMesDia).split('/');
            if (parts.length < 3) continue;
            const y = Number(parts[0]); const m = Number(parts[1]) - 1; const day = Number(parts[2]);
            if (Number.isNaN(y) || Number.isNaN(m) || Number.isNaN(day)) continue;
            const dt = new Date(y, m, day);
            const nome = getDiaSemana(dt);
            if (!nome) continue;
            const v = Number(d.receitaBruta ?? d.valor ?? 0) || 0;
            out[nome] = (Number(out[nome]) || 0) + v;
          }catch(e){ /* ignore malformed daily */ }
        }
        return out;
      }catch(e){ return zeroObj; }
    }

    // === NOVO: classifica√ß√£o por per√≠odo do dia e agrega√ß√£o mensal ===
    // Retorna 'Madrugada', 'Manh√£', 'Tarde' ou 'Noite' dado um timeStr 'HH:MM:SS'
    function getPeriodoDoDia(timeStr){
      try{
        if(!timeStr) return null;
        const m = String(timeStr).trim().replace('h',':').match(/^(\d{1,2}):(\d{1,2})(?::(\d{1,2}))?$/);
        if(!m){ 
          // fallback: tentar extrair a partir de uma data com hora (ex: '30/01/2025 18:37:21')
          const dt = parseToJSDate(String(timeStr));
          if(dt && !isNaN(dt.getTime())){
            const hh = dt.getHours(), mm = dt.getMinutes(), ss = dt.getSeconds();
            const t = (hh*3600)+(mm*60)+(ss);
            if(t>=1 && t<= 5*3600 + 59*60 + 59) return 'Madrugada';
            if(t>=6*3600 && t<= 11*3600 + 59*60 + 59) return 'Manh√£';
            if(t>=12*3600 && t<= 17*3600 + 59*60 + 59) return 'Tarde';
            if(t>=18*3600 && t<= 24*3600) return 'Noite';
            return 'Madrugada'; // fallback
          }
          return null;
        }
        const hh = Number(m[1]||0), mm = Number(m[2]||0), ss = Number(m[3]||0);
        const t = (hh*3600)+(mm*60)+(ss);
        // 00:00:01 a 05:59:59 - Madrugada (observando que 00:00:00 puro cai fora; vamos considerar 00:00:00 como Madrugada tamb√©m)
        if(t>=1 && t<= 5*3600 + 59*60 + 59) return 'Madrugada';
        if(t===0) return 'Madrugada';
        // 06:00:00 a 11:59:59 - Manh√£
        if(t>=6*3600 && t<= 11*3600 + 59*60 + 59) return 'Manh√£';
        // 12:00:00 a 17:59:59 - Tarde
        if(t>=12*3600 && t<= 17*3600 + 59*60 + 59) return 'Tarde';
        // 18:00:00 a 24:00:00 - Noite
        if(t>=18*3600 && t<= 24*3600) return 'Noite';
        return 'Madrugada';
      }catch(e){ return null; }
    }

    // Soma os valores por per√≠odo do dia dentro de um m√™s 'YYYY/MM'
    
    // === NOVO: utilit√°rios de consist√™ncia de totais ===
    function getTotalMensalPorAnoMes(anoMes){
      try{
        const detalhes = carregarVendasDetalhadas() || [];
        let total = 0;
        for(const tx of detalhes){
          if(!tx) continue;
          let d = null;
          if(tx.dateMs){ d = new Date(Number(tx.dateMs)); } else if(tx.date){ d = parseToJSDate(tx.date) || new Date(tx.date); }
          if(!d || isNaN(d.getTime())){
            const ex = extractDateTime(tx.date || tx.time || '');
            d = ex.dateObj;
          }
          if(!d || isNaN(d.getTime())) continue;
          const ym = `${d.getFullYear()}/${String(d.getMonth()+1).padStart(2,'0')}`;
          if(String(ym) !== String(anoMes)) continue;
          total += Number(tx.valorBruto || tx.value || tx.valor || 0) || 0;
        }
        return total;
      }catch(e){ console.warn('getTotalMensalPorAnoMes falhou', e); return 0; }
    }

    function getTotalSemanalPorAnoMes(anoMes){
      // Soma dos 7 dias (recomputando dos detalhes para evitar depend√™ncias)
      try{
        const detalhes = carregarVendasDetalhadas() || [];
        const byW = {0:0,1:0,2:0,3:0,4:0,5:0,6:0};
        for(const tx of detalhes){
          if(!tx) continue;
          let d = null;
          if(tx.dateMs){ d = new Date(Number(tx.dateMs)); } else if(tx.date){ d = parseToJSDate(tx.date) || new Date(tx.date); }
          if(!d || isNaN(d.getTime())){
            const ex = extractDateTime(tx.date || tx.time || '');
            d = ex.dateObj;
          }
          if(!d || isNaN(d.getTime())) continue;
          const ym = `${d.getFullYear()}/${String(d.getMonth()+1).padStart(2,'0')}`;
          if(String(ym) !== String(anoMes)) continue;
          const wd = d.getDay(); // 0..6
          byW[wd] += Number(tx.valorBruto || tx.value || tx.valor || 0) || 0;
        }
        return Object.values(byW).reduce((a,b)=>a+b,0);
      }catch(e){ console.warn('getTotalSemanalPorAnoMes falhou', e); return 0; }
    }

    function getTotalPeriodoPorAnoMes(anoMes){
      try{
        const sums = getSomaPeriodoPorMes(anoMes);
        return ['Madrugada','Manh√£','Tarde','Noite'].reduce((acc,k)=> acc + Number(sums[k]||0), 0);
      }catch(e){ console.warn('getTotalPeriodoPorAnoMes falhou', e); return 0; }
    }

    function getSomaPeriodoPorMes(anoMes){
      const zero = { 'Madrugada':0, 'Manh√£':0, 'Tarde':0, 'Noite':0 };
      if(!anoMes) return zero;
      try{
        // Prefer√™ncia: derivar a partir de vendasDetalhadas, pois cont√©m time por transa√ß√£o.
        // Se faltar time, tentamos extrair via extractDateTime().
        const detalhes = carregarVendasDetalhadas() || [];
        const out = { ...zero };
        for(const tx of detalhes){
          if(!tx) continue;
          // Determina se pertence ao ano/mes pedido
          let d = null;
          if(tx.dateMs){ d = new Date(Number(tx.dateMs)); } else if(tx.date){ d = parseToJSDate(tx.date) || new Date(tx.date); }
          if(!d || isNaN(d.getTime())){
            // tenta extrair de um campo combinado (ex: '30/01/2025 18:37:21')
            const ex = extractDateTime(tx.date || tx.time || '');
            d = ex.dateObj;
          }
          if(!d || isNaN(d.getTime())) continue;
          const ym = `${d.getFullYear()}/${String(d.getMonth()+1).padStart(2,'0')}`;
          if(String(ym) !== String(anoMes)) continue;

          // time string: prefer explicit tx.time; otherwise attempt extractDateTime but only accept
          // the extracted time if the original raw contains a time-like token (':' or 'T') or
          // if the original looks like an Excel serial with fractional part.
          let timeStr = tx.time || null;
          if(!timeStr){
            const rawDateStr = tx.date || '';
            const ex = extractDateTime(rawDateStr || '');
            // accept extracted time only when original text contains ':' (explicit time) or 'T' (ISO)
            // or when rawDateStr contains a fractional numeric token (e.g., '45688 25569.83')
            const hasTimeLike = (typeof rawDateStr === 'string' && (rawDateStr.indexOf(':') !== -1 || rawDateStr.indexOf('T') !== -1));
            const hasFractionSerial = (typeof rawDateStr === 'string' && /\d+\.\d+/.test(rawDateStr));
            if(ex && ex.timeStr && (hasTimeLike || hasFractionSerial)){
              timeStr = ex.timeStr;
            } else {
              timeStr = null; // don't assume midnight when we don't have explicit time
            }
          }
          // treat explicit midnight '00:00:00' as missing time (don't assume period)
          if(timeStr === '00:00:00') timeStr = null;
          const periodo = getPeriodoDoDia(timeStr);
          const valor = Number(tx.valorBruto || tx.value || tx.valor || 0) || 0;
          if(periodo && (periodo in out)){ out[periodo] = (Number(out[periodo])||0) + valor; }
        }
        return out;
      }catch(e){ return zero; }
    }

    // Export vendasDetalhadas as downloadable JSON file
    function exportVendasDetalhadas(){
      try{
        const arr = carregarVendasDetalhadas() || [];
        const blob = new Blob([JSON.stringify(arr, null, 2)], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        const fileName = `vendasDetalhadas_export_${Date.now()}.json`;
        a.href = url; a.download = fileName; document.body.appendChild(a); a.click(); a.remove();
        setTimeout(()=> URL.revokeObjectURL(url), 1000);
        return true;
      }catch(e){ console.error('Erro ao exportar vendasDetalhadas', e); return false; }
    }

    // Force dedupe + rebuild from vendasDetalhadas and refresh UI
    function forceRebuildFromDetalhadas(){
      try{
        console.info('Executando forceRebuildFromDetalhadas...');
        // Migration: normalize source values in existing vendasDetalhadas so 'PIX' variants become 'pix'
        try{
          const arr = carregarVendasDetalhadas() || [];
          let changed = 0;
          for(let i=0;i<arr.length;i++){
            const x = arr[i]; if(!x) continue;
            const rawSrc = (x.source || '').toString().trim();
            const srcLow = rawSrc.toLowerCase();
            let newSrc = rawSrc;
            if(!rawSrc){
              // infer from tipoPagamento or id
              const tp = (x.tipoPagamento || '').toString().toLowerCase();
              if(tp.indexOf('pix') !== -1) newSrc = 'pix';
              else if(tp.indexOf('deb') !== -1 || tp.indexOf('cred') !== -1 || tp.indexOf('cart') !== -1) newSrc = 'cartao';
            } else {
              if(srcLow.indexOf('pix') !== -1) newSrc = 'pix';
              else if(srcLow.indexOf('cart') !== -1 || srcLow.indexOf('cred') !== -1 || srcLow.indexOf('deb') !== -1) newSrc = 'cartao';
              else newSrc = srcLow; // keep normalized lower-case
            }
            if(newSrc !== rawSrc){ arr[i].source = newSrc; changed++; }
          }
          if(changed>0){ salvarVendasDetalhadas(arr); console.info('Normalized source for', changed, 'records'); }
        }catch(e){ console.warn('source normalization migration failed', e); }

        if(typeof dedupeVendasDetalhadas === 'function') try{ dedupeVendasDetalhadas(); console.info('dedupeVendasDetalhadas OK'); }catch(e){ console.warn('dedupeVendasDetalhadas falhou', e); }
        if(typeof rebuildDailyFromDetalhadas === 'function') try{ rebuildDailyFromDetalhadas(); console.info('rebuildDailyFromDetalhadas OK'); }catch(e){ console.warn('rebuildDailyFromDetalhadas falhou', e); }
        if(typeof computeMonthlyResumoFromDaily === 'function') try{ computeMonthlyResumoFromDaily(); console.info('computeMonthlyResumoFromDaily OK'); }catch(e){ console.warn('computeMonthlyResumoFromDaily falhou', e); }
        if(typeof computeWeekdaySumsPerMonth === 'function') try{ computeWeekdaySumsPerMonth(); console.info('computeWeekdaySumsPerMonth OK'); }catch(e){ console.warn('computeWeekdaySumsPerMonth falhou', e); }
        atualizarSelectAnos(); const sel = document.getElementById('select-anos-receitas'); if(sel && sel.value) renderizarReceitasAno(sel.value);
        return true;
      }catch(e){ console.error('forceRebuildFromDetalhadas falhou', e); return false; }
    }


    function getWeekdaySumsForMonth(anoMes){
      try{ const p = JSON.parse(localStorage.getItem('vendas_por_dia_semana') || '{}'); return p[anoMes] || { '0':0,'1':0,'2':0,'3':0,'4':0,'5':0,'6':0 }; }catch(e){ return { '0':0,'1':0,'2':0,'3':0,'4':0,'5':0,'6':0 }; }
    }

    // Inputs
    const fileInputCartao = document.getElementById('fileInputCartao');
    const fileNameCartao = document.getElementById('fileNameCartao');
    const processarBtnCartao = document.getElementById('processarBtnCartao');

    const fileInputPix = document.getElementById('fileInputPix');
    const fileNamePix = document.getElementById('fileNamePix');
    const processarBtnPix = document.getElementById('processarBtnPix');

    let arquivosSelecionadosCartao = [];
    let arquivosSelecionadosPix = [];

    // --- Header mapping helpers ---
    function detectHeaderRow(json){
      // tenta escolher a linha com mais c√©lulas texto (primeiras 10 linhas)
      let best = {idx:0, score: -1};
      for (let i=0;i<Math.min(10,json.length);i++){
        const row = json[i] || [];
        let score = 0;
        for (const cell of row){ if (cell !== null && cell !== undefined && String(cell).trim().length>0) score += 1; }
        if (score > best.score){ best = {idx:i, score}; }
      }
      return best.idx;
    }

    function getHeadersFromJson(json, overrideHeaderRow){
      const hr = (typeof overrideHeaderRow === 'number' && !isNaN(overrideHeaderRow)) ? overrideHeaderRow : detectHeaderRow(json);
      const headerRow = json[hr] || [];
      return headerRow.map(h => h==null? '': String(h).trim());
    }

    function loadMapping(key){
      try{ return JSON.parse(localStorage.getItem(key)) || {}; } catch(e){ return {}; }
    }
    function saveMapping(key, map){ try{ localStorage.setItem(key, JSON.stringify(map)); }catch(e){} }

    function renderMappingUI(panelId, fieldsContainerId, headers, storageKey, defaults){
      const panel = document.getElementById(panelId);
      const container = document.getElementById(fieldsContainerId);
      if(!panel || !container) return;
      container.innerHTML='';
  const mapping = loadMapping(storageKey) || {};
  // if saved mapping only contains headerRow (from import config) treat it as empty so auto-detect runs
  const userMappingKeys = Object.keys(mapping).filter(k => k !== 'headerRow');
  const auto = (userMappingKeys.length === 0) ? autoMapHeaders(headers, defaults) : {};
      const options = [''].concat(headers);
      // also offer numeric index options up to headers length-1
      for (const f of defaults){
        const row = document.createElement('div');
        row.className='flex items-center gap-2';
        const label = document.createElement('div'); label.className='w-36 text-xs text-gray-600'; label.textContent = f.label;
        const sel = document.createElement('select'); sel.className='map-select rounded border px-2 py-1 text-sm flex-1';
        // option for automatic index by header name
        sel.innerHTML = options.map(o => `<option value="${o}">${o||'(nenhum)'}</option>`).join('') +
                        Array.from({length: Math.max(0, Math.min(30, headers.length+5))}).map((_,i)=>`<option value="__idx__${i}">√çndice ${i}</option>`).join('');
        // set current value from mapping, auto-detect or default
        const current = (mapping[f.key] || auto[f.key] || f.default);
        if(current!==undefined && current!==null){ sel.value = current; }
        row.appendChild(label); row.appendChild(sel);
        container.appendChild(row);
      }
      // show panel
      panel.classList.remove('hidden');
    }

    function normalizeForMatch(s){ if(!s) return ''; try{ return String(s).toLowerCase().normalize('NFD').replace(/\p{Diacritic}/gu,''); }catch(e){ return String(s).toLowerCase(); } }

    function autoMapHeaders(headers, defaults){
      const map = {};
      const norm = headers.map(h => normalizeForMatch(h||''));
      function findByWords(words){
        for (let i=0;i<norm.length;i++){ const h = norm[i]; for (const w of words){ if(w && h.includes(w)) return headers[i]; } }
        return null;
      }
      // heuristics per key
      defaults.forEach(d => {
        const k = d.key;
        let found = null;
        if(k === 'date'){
          found = findByWords(['data','date','emissao','emiss√£o','timestamp','dia']);
        } else if(k === 'time'){
          found = findByWords(['hora','time','horario']);
        } else if(k === 'status'){
          found = findByWords(['status','situacao','situa√ß√£o','estado','estado da']);
        } else if(k === 'valorBruto'){
          found = findByWords(['valor da venda atualizado','valor da venda original','valor da venda','valor atualizado','valor original','valor bruto','valor','amount','valorvenda']);
        } else if(k === 'modalidade'){
          found = findByWords(['modalidade','tipo','tipo de pagamento','forma']);
        } else if(k === 'valorMdr' || k === 'mdr'){
          found = findByWords(['mdr','taxa mdr','taxa mdr','taxa','taxa mdr']);
        } else if(k === 'valorLiquido'){
          found = findByWords(['valor liquido','valor l√≠quido','liquido','liquidado','liquido','liquid']);
        }
        // fallback: try to find words from key name
        if(!found){ found = findByWords([normalizeForMatch(k)]); }
        // if still not found, try to guess by index common patterns (e.g., valorBruto prefer column 4 etc.) -- use header index if present
        if(!found){
          // no header match, try numeric fallback: look for header containing 'valor' for valor fields
          if(k === 'valorBruto' || k === 'valorLiquido' || k === 'valorMdr'){
            found = findByWords(['valor']);
          }
        }
        if(found){ map[k] = found; }
      });
      // special case: if time wasn't found but date was found (common when date and time are in same cell), map time to the same header as date
      if(!map.time && map.date){ map.time = map.date; }
      return map;
    }

    function readFirstFileHeaders(file, headerRowOverride){
      return new Promise(async (resolve, reject)=>{
        try{
          const data = await readFileArrayBufferWithRetry(file);
          const workbook = XLSX.read(new Uint8Array(data), {type:'array'});
          const sheet = workbook.Sheets[workbook.SheetNames[0]];
          const json = XLSX.utils.sheet_to_json(sheet, {header:1});
          const headers = getHeadersFromJson(json, headerRowOverride);
          resolve({headers,json});
        }catch(err){ reject(err); }
      });
    }

    function applyMappingIndex(headers, mappingValue, fallbackIndex){
      if(!mappingValue) return fallbackIndex;
      if(String(mappingValue).startsWith('__idx__')){
        const n = Number(String(mappingValue).replace('__idx__',''));
        return Number.isFinite(n) ? n : fallbackIndex;
      }
      // try find header name
      const idx = headers.indexOf(String(mappingValue));
      return idx >= 0 ? idx : fallbackIndex;
    }

    // L√™ um File/Blob em ArrayBuffer com retries para contornar locks tempor√°rios do SO (ex: arquivo aberto no Excel/OneDrive)
    async function readFileArrayBufferWithRetry(file, attempts = 4, delayMs = 400){
      for(let i=0;i<attempts;i++){
        try{
          return await file.arrayBuffer();
        }catch(err){
          // √∫ltima tentativa: lan√ßa um erro mais amig√°vel
          if(i === attempts - 1){
            const msg = (err && err.message) ? err.message : String(err);
            throw new Error('N√£o foi poss√≠vel ler o arquivo. Feche-o no Excel/OneDrive (se aberto) e tente novamente. Detalhe t√©cnico: ' + msg);
          }
          // aguarda um pouco antes de tentar novamente
          await new Promise(r => setTimeout(r, delayMs));
        }
      }
    }


    // --- helpers para sincronizar MDR como despesas ---
    function genIdLocal() { return (Date.now().toString(36) + Math.random().toString(36).slice(2,8)); }
    function carregarDespesas() { try { return JSON.parse(localStorage.getItem('despesas')) || []; } catch(e){ return []; } }
    function salvarDespesas(ds) { try { localStorage.setItem('despesas', JSON.stringify(ds)); } catch(e){} }

    // Recebe um array de objetos resumoPorMes (val) e sincroniza lan√ßamentos MDR em despesas
    function syncMdrToDespesas(vals){
      // Defensive: aggregate incoming vals by unique key (source||anoMes||tipo) so we create/keep
      // only one automatic despesa por m√™s+fonte+tipo, summing MDR when multiple daily inputs arrive.
      if (!Array.isArray(vals) || vals.length===0) return;
      const despesas = carregarDespesas();
      // aggregate incoming vals by key
      const agg = new Map();
      for (const v of vals){
        if (!v || !v.anoMes) continue;
        const key = `${v.source}||${v.anoMes}||${v.tipoPagamento||''}`;
        const mdrVal = Number(v.mdr || 0);
        if (mdrVal <= 0) continue;
        if (!agg.has(key)) agg.set(key, { source: v.source, anoMes: v.anoMes, tipoPagamento: v.tipoPagamento||'', mdr: 0 });
        const cur = agg.get(key);
        cur.mdr = (Number(cur.mdr) || 0) + mdrVal;
        agg.set(key, cur);
      }
      // build set of keys to keep
      const newKeys = Array.from(agg.keys());
      // remove existing automatic despesas that are for keys that are NOT in newKeys
      const filtered = despesas.filter(d => !d.autoFromVendasKey || newKeys.indexOf(d.autoFromVendasKey) === -1);
      // Now, add one despesa per aggregated key
      const MONTHS_PT = ['Janeiro','Fevereiro','Mar√ßo','Abril','Maio','Junho','Julho','Agosto','Setembro','Outubro','Novembro','Dezembro'];
      for (const [key, data] of agg.entries()){
        const parts = String(data.anoMes||'').split('/');
        const ano = parts[0] || String(new Date().getFullYear());
        const mesNum = parts[1] ? Number(parts[1]) : null;
        const mesNome = (mesNum && mesNum>=1 && mesNum<=12) ? MONTHS_PT[mesNum-1] : MONTHS_PT[new Date().getMonth()];
        // calcula o √∫ltimo dia do m√™s para usar como dia padr√£o
        let lastDay = 1;
        try{
          if (mesNum && !isNaN(Number(ano))) {
            lastDay = new Date(Number(ano), Number(mesNum), 0).getDate();
          } else {
            const d = new Date(); lastDay = new Date(d.getFullYear(), d.getMonth()+1, 0).getDate();
          }
        } catch(e){ lastDay = 1; }
        const item = {
          id: genIdLocal(),
          ano: String(ano),
          mes: mesNome,
          dia: lastDay,
          tipo: 'Vari√°vel',
          categoria: 'Taxas de Vendas (MDR)',
          descricao: `MDR ${data.source || ''} ${data.tipoPagamento || ''}`.trim(),
          valor: Number(data.mdr || 0),
          autoFromVendasKey: key
        };
        filtered.push(item);
      }
      salvarDespesas(filtered);
      try { localStorage.setItem('despesas_last_update', String(Date.now())); } catch(e){}
    }

    // Remove despesas autom√°ticas (MDR) geradas a partir de chaves de vendas
    // keys: array de chaves no formato usado na tabela: `${anoMes}__${source}__${tipo}`
    function removerDespesasMdrPorVendasKeys(keys){
      try{
        if(!Array.isArray(keys) || keys.length===0) return;
        const despesas = carregarDespesas();
        const autoKeysSet = new Set(keys.map(k=>{
          const parts = String(k||'').split('__');
          const anoMes = parts[0]||'';
          const source = parts[1]||'';
          const tipo = parts[2]||'';
          return `${source}||${anoMes}||${tipo}`; // mesmo formato usado em autoFromVendasKey
        }));
        const filtered = despesas.filter(d => !(d && d.autoFromVendasKey && autoKeysSet.has(d.autoFromVendasKey)));
        salvarDespesas(filtered);
        try{ localStorage.setItem('despesas_last_update', String(Date.now())); }catch(e){}
      }catch(err){ console.warn('Erro ao remover despesas MDR por chaves de vendas', err); }
    }

    if(fileInputCartao){
      fileInputCartao.addEventListener('change', (e)=>{
        const files = e.target.files ? Array.from(e.target.files) : [];
        arquivosSelecionadosCartao = files;
        fileNameCartao.textContent = files.length ? `Arquivos: ${files.map(f=>f.name).join(', ')}` : '';
        processarBtnCartao.disabled = files.length === 0;
      });
    }
    if(fileInputPix){
      fileInputPix.addEventListener('change', (e)=>{
        const files = e.target.files ? Array.from(e.target.files) : [];
        arquivosSelecionadosPix = files;
        fileNamePix.textContent = files.length ? `Arquivos: ${files.map(f=>f.name).join(', ')}` : '';
        processarBtnPix.disabled = files.length === 0;
      });
    }

  // Config / mapping UI wiring
  const btnSaveCartao = document.getElementById('save-mapping-cartao');
  const btnResetCartao = document.getElementById('reset-mapping-cartao');

  const btnSavePix = document.getElementById('save-mapping-pix');
  const btnResetPix = document.getElementById('reset-mapping-pix');

    // when files selected, try to read first file header to populate mapping selects
    async function tryPopulateCartaoMapping(headerRowOverride){
      if(!arquivosSelecionadosCartao || arquivosSelecionadosCartao.length===0) return;
      try{
        const {headers} = await readFirstFileHeaders(arquivosSelecionadosCartao[0], headerRowOverride);
        renderMappingUI('mapping-cartao-panel','mapping-cartao-fields', headers, 'mapping_cartao', [
          {key:'date', label:'Data (data da venda)', default:''},
          {key:'time', label:'Hora (hora da venda)', default:''},
          {key:'status', label:'Status (aprovada/negada)', default:''},
          {key:'valorBruto', label:'Valor (valor da venda atualizado)', default:''},
          {key:'modalidade', label:'Modalidade (credito/debito)', default:''},
          {key:'valorMdr', label:'Valor MDR', default:''},
          {key:'valorLiquido', label:'Valor L√≠quido', default:''}
        ]);
      }catch(e){ console.warn('N√£o foi poss√≠vel detectar cabe√ßalho (cart√£o):', e); }
    }

    async function tryPopulatePixMapping(headerRowOverride){
      if(!arquivosSelecionadosPix || arquivosSelecionadosPix.length===0) return;
      try{
        const {headers} = await readFirstFileHeaders(arquivosSelecionadosPix[0], headerRowOverride);
        // use the same default mapping fields/labels as Cart√£o so PIX mapping panel shows the same options
        renderMappingUI('mapping-pix-panel','mapping-pix-fields', headers, 'mapping_pix', [
          {key:'date', label:'Data (data da venda)', default:''},
          {key:'time', label:'Hora (hora da venda)', default:''},
          {key:'status', label:'Status (aprovada/negada)', default:''},
          {key:'valorBruto', label:'Valor (valor da venda atualizado)', default:''},
          {key:'modalidade', label:'Modalidade (credito/debito)', default:''},
          {key:'valorMdr', label:'Valor MDR', default:''},
          {key:'valorLiquido', label:'Valor L√≠quido', default:''}
        ]);
      }catch(e){ console.warn('N√£o foi poss√≠vel detectar cabe√ßalho (pix):', e); }
    }

    if(fileInputCartao){ fileInputCartao.addEventListener('change', tryPopulateCartaoMapping); }
    if(fileInputPix){ fileInputPix.addEventListener('change', tryPopulatePixMapping); }

    // import config panel wiring
    const btnOpenImportConfig = document.getElementById('btn-open-import-config');
    const importConfigPanel = document.getElementById('import-config-panel');
    const inputHeaderCartao = document.getElementById('headerline-cartao');
    const inputHeaderPix = document.getElementById('headerline-pix');
    const btnSaveImportConfig = document.getElementById('save-import-config');
    const btnOpenMappingCartao = document.getElementById('open-mapping-cartao');
    const btnOpenMappingPix = document.getElementById('open-mapping-pix');

    if(btnOpenImportConfig){ btnOpenImportConfig.addEventListener('click', ()=>{
      if(!importConfigPanel) return;
      const isOpen = importConfigPanel.classList.contains('opacity-100');
      const panels = document.getElementById('import-panels');
      const btnToggle = document.getElementById('btn-toggle-import');
      if(!isOpen){
        // open import-config-panel (add open classes)
        importConfigPanel.classList.remove('max-h-0','opacity-0','-translate-y-2');
        importConfigPanel.classList.add('max-h-[1000px]','opacity-100','translate-y-0');
        importConfigPanel.classList.remove('md:scale-95'); importConfigPanel.classList.add('md:scale-100');
        // close import panels
        if(panels){ panels.classList.remove('max-h-[1000px]','opacity-100','translate-y-0'); panels.classList.add('max-h-0','opacity-0','-translate-y-2'); panels.classList.remove('md:scale-100'); panels.classList.add('md:scale-95'); }
        if(btnToggle) btnToggle.textContent = 'Importar Vendas';
      } else {
        // close import-config-panel
        importConfigPanel.classList.remove('max-h-[1000px]','opacity-100','translate-y-0');
        importConfigPanel.classList.add('max-h-0','opacity-0','-translate-y-2');
        importConfigPanel.classList.remove('md:scale-100'); importConfigPanel.classList.add('md:scale-95');
      }
    }); }

    // load saved header rows into inputs if exist
    try{
      const savedCartao = loadMapping('mapping_cartao') || {};
      if(savedCartao.headerRow !== undefined && savedCartao.headerRow !== null){ inputHeaderCartao.value = (Number(savedCartao.headerRow) + 1); }
      const savedPix = loadMapping('mapping_pix') || {};
      if(savedPix.headerRow !== undefined && savedPix.headerRow !== null){ inputHeaderPix.value = (Number(savedPix.headerRow) + 1); }
    }catch(e){}

    if(btnSaveImportConfig){ btnSaveImportConfig.addEventListener('click', ()=>{
      const cartaoVal = Number(inputHeaderCartao.value);
      const pixVal = Number(inputHeaderPix.value);
      if(!Number.isFinite(cartaoVal) || cartaoVal < 1){ alert('Linha do cabe√ßalho (Cart√µes) deve ser um n√∫mero inteiro >= 1'); return; }
      if(!Number.isFinite(pixVal) || pixVal < 1){ alert('Linha do cabe√ßalho (PIX) deve ser um n√∫mero inteiro >= 1'); return; }
      const mc = loadMapping('mapping_cartao') || {}; mc.headerRow = Math.max(0, Math.floor(cartaoVal)-1); saveMapping('mapping_cartao', mc);
      const mp = loadMapping('mapping_pix') || {}; mp.headerRow = Math.max(0, Math.floor(pixVal)-1); saveMapping('mapping_pix', mp);
      // after saving config, collapse mapping panels (they use hidden)
      const mcp = document.getElementById('mapping-cartao-panel'); if(mcp) mcp.classList.add('hidden');
      const mpp = document.getElementById('mapping-pix-panel'); if(mpp) mpp.classList.add('hidden');
      // also collapse the import-config-panel using transitions
      const importCfg = document.getElementById('import-config-panel'); if(importCfg){ importCfg.classList.remove('max-h-[1000px]','opacity-100','translate-y-0'); importCfg.classList.add('max-h-0','opacity-0','-translate-y-2'); importCfg.classList.remove('md:scale-100'); importCfg.classList.add('md:scale-95'); }
      alert('Configura√ß√µes de importa√ß√£o salvas.');
    }); }

    if(btnOpenMappingCartao){ btnOpenMappingCartao.addEventListener('click', async ()=>{
      const panel = document.getElementById('mapping-cartao-panel');
      if(panel && !panel.classList.contains('hidden')){ panel.classList.add('hidden'); return; }
      // if no file selected in upload, show sample file input and wait for user to pick a file
      if(!arquivosSelecionadosCartao || arquivosSelecionadosCartao.length===0){
        // reveal panel and let user choose sample file
        document.getElementById('mapping-cartao-panel')?.classList.remove('hidden');
        const sampleInput = document.getElementById('mapping-cartao-sample-file');
        if(sampleInput){
          sampleInput.value = null;
          sampleInput.onchange = async (e)=>{
            const f = e.target.files && e.target.files[0]; if(!f) return;
            try{ const {headers} = await readFirstFileHeaders(f, loadMapping('mapping_cartao')?.headerRow); renderMappingUI('mapping-cartao-panel','mapping-cartao-fields', headers, 'mapping_cartao', [
                {key:'date', label:'Data (data da venda)', default:''},
                {key:'time', label:'Hora (hora da venda)', default:''},
                {key:'status', label:'Status (aprovada/negada)', default:''},
                {key:'valorBruto', label:'Valor (valor da venda atualizado)', default:''},
                {key:'modalidade', label:'Modalidade (credito/debito)', default:''},
                {key:'valorMdr', label:'Valor MDR', default:''},
                {key:'valorLiquido', label:'Valor L√≠quido', default:''}
              ]);
            }catch(err){ console.warn('Erro ao ler arquivo amostra (cart√£o):', err); alert('Erro ao ler arquivo amostra.'); }
          };
        }
        return;
      }
      // ensure import-config-panel is expanded so mapping panel buttons are visible
      try{
        const importCfg = document.getElementById('import-config-panel');
        if(importCfg){ importCfg.classList.remove('max-h-0','opacity-0','-translate-y-2'); importCfg.classList.add('max-h-[1000px]','opacity-100','translate-y-0'); importCfg.classList.remove('md:scale-95'); importCfg.classList.add('md:scale-100'); }
      }catch(e){}
      const m = loadMapping('mapping_cartao') || {}; const hv = (m.headerRow !== undefined ? m.headerRow : (Number(inputHeaderCartao.value||2)-1));
      await tryPopulateCartaoMapping(hv);
      document.getElementById('mapping-cartao-panel')?.classList.remove('hidden');
    }); }

    if(btnOpenMappingPix){ btnOpenMappingPix.addEventListener('click', async ()=>{
      const panel = document.getElementById('mapping-pix-panel');
      if(panel && !panel.classList.contains('hidden')){ panel.classList.add('hidden'); return; }
      if(!arquivosSelecionadosPix || arquivosSelecionadosPix.length===0){
        document.getElementById('mapping-pix-panel')?.classList.remove('hidden');
        const sampleInput = document.getElementById('mapping-pix-sample-file');
        if(sampleInput){
          sampleInput.value = null;
          sampleInput.onchange = async (e)=>{
            const f = e.target.files && e.target.files[0]; if(!f) return;
            try{ const {headers} = await readFirstFileHeaders(f, loadMapping('mapping_pix')?.headerRow); 
              // use the same default mapping fields/labels as Cart√£o
              renderMappingUI('mapping-pix-panel','mapping-pix-fields', headers, 'mapping_pix', [
                {key:'date', label:'Data (data da venda)', default:''},
                {key:'time', label:'Hora (hora da venda)', default:''},
                {key:'status', label:'Status (aprovada/negada)', default:''},
                {key:'valorBruto', label:'Valor (valor da venda atualizado)', default:''},
                {key:'modalidade', label:'Modalidade (credito/debito)', default:''},
                {key:'valorMdr', label:'Valor MDR', default:''},
                {key:'valorLiquido', label:'Valor L√≠quido', default:''}
              ]);
            }catch(err){ console.warn('Erro ao ler arquivo amostra (pix):', err); alert('Erro ao ler arquivo amostra.'); }
          };
        }
        return;
      }
      // ensure import-config-panel is expanded so mapping panel buttons are visible
      try{
        const importCfg = document.getElementById('import-config-panel');
        if(importCfg){ importCfg.classList.remove('max-h-0','opacity-0','-translate-y-2'); importCfg.classList.add('max-h-[1000px]','opacity-100','translate-y-0'); importCfg.classList.remove('md:scale-95'); importCfg.classList.add('md:scale-100'); }
      }catch(e){}
      const m = loadMapping('mapping_pix') || {}; const hv = (m.headerRow !== undefined ? m.headerRow : (Number(inputHeaderPix.value||2)-1));
      await tryPopulatePixMapping(hv);
      document.getElementById('mapping-pix-panel')?.classList.remove('hidden');
    }); }

    

    // save mapping: reads selects inside fields container and stores map
    if(btnSaveCartao){ btnSaveCartao.addEventListener('click', ()=>{
      const container = document.getElementById('mapping-cartao-fields'); if(!container) return;
      const selects = Array.from(container.querySelectorAll('select'));
      const keys = ['date','time','status','valorBruto','modalidade','valorMdr','valorLiquido'];
      const map = {};
      selects.forEach((s,i)=>{ if(keys[i]) map[keys[i]] = s.value; });
      saveMapping('mapping_cartao', map);
      alert('Modelo de Cart√£o salvo.');
    }); }
    if(btnResetCartao){ btnResetCartao.addEventListener('click', ()=>{ localStorage.removeItem('mapping_cartao'); alert('Modelo de Cart√£o resetado.'); }); }

    if(btnSavePix){ btnSavePix.addEventListener('click', ()=>{
      const container = document.getElementById('mapping-pix-fields'); if(!container) return;
      const selects = Array.from(container.querySelectorAll('select'));
      // save the full set of mapping keys (same as Cart√£o) so PIX mapping persists the same fields
      const keys = ['date','time','status','valorBruto','modalidade','valorMdr','valorLiquido'];
      const map = {};
      selects.forEach((s,i)=>{ if(keys[i]) map[keys[i]] = s.value; });
      saveMapping('mapping_pix', map);
      alert('Modelo de PIX salvo.');
    }); }
    if(btnResetPix){ btnResetPix.addEventListener('click', ()=>{ localStorage.removeItem('mapping_pix'); alert('Modelo de PIX resetado.'); }); }

    // ===== Processar Cart√µes =====
    if(processarBtnCartao){
      processarBtnCartao.addEventListener('click', async ()=>{
        if (!arquivosSelecionadosCartao.length) return;
        processarBtnCartao.disabled = true;
  let resumoPorDia = {};
  let totalVendas = 0;
  let detalheBuffer = [];
        try{
          const savedMap = loadMapping('mapping_cartao') || {};
          for (const arquivo of arquivosSelecionadosCartao){
            const data = await readFileArrayBufferWithRetry(arquivo);
            const workbook = XLSX.read(new Uint8Array(data), {type: 'array'});
            const sheet = workbook.Sheets[workbook.SheetNames[0]];
            const json = XLSX.utils.sheet_to_json(sheet, {header:1});

            // detect header row and headers
            const headerRowIndex = (typeof savedMap.headerRow === 'number') ? savedMap.headerRow : detectHeaderRow(json);
            const headers = (json[headerRowIndex] || []).map(h => h==null? '': String(h).trim());

            for (let i = headerRowIndex+1; i<json.length; i++){
              let row = json[i]; if(!row) continue;
              if (Array.isArray(row) && row.length===1 && typeof row[0]==='string' && row[0].includes(';')){ row = row[0].split(';').map(c => c==null ? '' : String(c).trim()); }

              // resolve indices by mapping or fallback to legacy indices
              const idxDate = applyMappingIndex(headers, savedMap.date || savedMap.data || savedMap.dataDaVenda, 0);
              const idxStatus = applyMappingIndex(headers, savedMap.status || savedMap.statusVenda, 2);
              const idxValorBruto = applyMappingIndex(headers, savedMap.valorBruto || savedMap.valorVendaAtualizado || savedMap['valor da venda atualizado'], 4);
              const idxModalidade = applyMappingIndex(headers, savedMap.modalidade || savedMap.tipo || savedMap['modalidade'], 5);
              const idxMdr = applyMappingIndex(headers, savedMap.valorMdr || savedMap.mdr || savedMap['valor mdr'], 11);
              const idxValorLiquido = applyMappingIndex(headers, savedMap.valorLiquido || savedMap['valor liquido'] , 16);

              const status = String(row[idxStatus]||'').trim().toLowerCase(); if (status === 'negada') continue;

              // obter data completa e normalizar para YYYY/MM/DD
              let anoMes = 'Indefinido';
              let anoMesDia = 'Indefinido';
              try{
                const dateObj = parseToJSDate(row[idxDate]);
                if (dateObj && !isNaN(dateObj.getTime())){
                  const y = dateObj.getFullYear(); const m = String(dateObj.getMonth()+1).padStart(2,'0'); const day = String(dateObj.getDate()).padStart(2,'0');
                  anoMes = `${y}/${m}`;
                  anoMesDia = `${y}/${m}/${day}`;
                } else {
                  const parsed = parseDateToAnoMes(row[idxDate]) || {}; anoMes = parsed.anoMes || 'Indefinido';
                }
              }catch(e){ anoMes = (parseDateToAnoMes(row[idxDate])||{}).anoMes || 'Indefinido'; }
              const modalidadeRaw = (row[idxModalidade]||'').toString().trim().toLowerCase();
              const modalidadeNorm = modalidadeRaw.normalize ? modalidadeRaw.normalize('NFD').replace(/\p{Diacritic}/gu,'').replace(/\s+/g,'') : modalidadeRaw;
              let tipoPagamento = '';
              if (modalidadeNorm.includes('debito') || modalidadeNorm.includes('deb')) tipoPagamento = 'D√©bito';
              else if (modalidadeNorm.includes('credito') || modalidadeNorm.includes('cred')) tipoPagamento = 'Cr√©dito';
              else if (modalidadeNorm.includes('pix')) tipoPagamento = 'PIX';
              if (tipoPagamento!=='D√©bito' && tipoPagamento!=='Cr√©dito') continue;

              const valorBruto = parseNumber(row[idxValorBruto]);
              const valorMDR  = parseNumber(row[idxMdr]);

              // save transaction-level detail (mant√©m granularidade por linha) - cart√£o: time pode estar em coluna separada
              try{
                const idxTime = applyMappingIndex(headers, savedMap.time || savedMap.hora || savedMap.timeVenda, 1);
                const rawDate = row[idxDate];
                const rawTime = row[idxTime];
                const combined = (rawDate ? String(rawDate) : '') + (rawTime ? (' ' + String(rawTime)) : '');
                const dt = extractDateTime(combined || rawDate);
                // push raw object with known amount fields; normalization will occur in addVendasDetalhadasBulk
                // store the raw combined date/time string so normalizeVendaDetalhada can re-parse if initial extract failed
                const rawObj = { date: combined || rawDate, dateMs: dt && dt.dateObj ? dt.dateObj.getTime() : null, time: dt && dt.timeStr ? dt.timeStr : (rawTime || null), valorBruto: valorBruto, mdr: valorMDR, valorLiquido: (parseNumber(row[idxValorLiquido]) || (valorBruto - valorMDR)), source: 'cartao', tipoPagamento };
                  detalheBuffer.push(rawObj);
              }catch(e){ /* ignore */ }

              // agregar por dia (YYYY/MM/DD)
              const keyDia = `${anoMesDia}||${tipoPagamento}`;
              if(!resumoPorDia[keyDia]) resumoPorDia[keyDia] = {receitaBruta:0, mdr:0, anoMesDia, anoMes, source:'cartao', tipoPagamento};
              resumoPorDia[keyDia].receitaBruta += valorBruto;
              resumoPorDia[keyDia].mdr          += valorMDR;
              resumoPorDia[keyDia].receitaLiquida = resumoPorDia[keyDia].receitaBruta - resumoPorDia[keyDia].mdr;
              totalVendas++;
            }
          }

          // gravar vendas detalhadas em lote (mais eficiente) e reconstruir agrega√ß√µes a partir dos detalhes
          try{
            if(Array.isArray(detalheBuffer) && detalheBuffer.length>0){
              const beforeCount = (JSON.parse(localStorage.getItem('vendasDetalhadas')||'[]')||[]).filter(x=>x && x.source==='cartao').length;
              const added = await addVendasDetalhadasBulk(detalheBuffer);
              const afterCount = (JSON.parse(localStorage.getItem('vendasDetalhadas')||'[]')||[]).filter(x=>x && x.source==='cartao').length;
              console.info('[IMPORT CARTAO] detalheBuffer rows:', detalheBuffer.length, 'added:', added, 'before:', beforeCount, 'after:', afterCount);
              if(added > 0){ console.debug('[IMPORT CARTAO] sample added items:', JSON.parse(localStorage.getItem('vendasDetalhadas')||'[]').filter(x=>x && x.source==='cartao').slice(Math.max(0, afterCount-10), afterCount)); }
            }
            // rebuild di√°rio/mensal a partir do conjunto completo de vendasDetalhadas
            const daily = rebuildDailyFromDetalhadas();
            const monthlyResumo = computeMonthlyResumoFromDaily();
            try { syncMdrToDespesas(monthlyResumo); } catch(e){ console.warn('syncMdrToDespesas falhou', e); }
            try{ computeWeekdaySumsPerMonth(); }catch(e){ /* ignore */ }
          }catch(e){ console.error('Erro durante persist√™ncia/rebuild (cart√µes):', e); }
          alert(`Importa√ß√£o conclu√≠da: ${totalVendas} registros processados (cart√µes).`);
          atualizarSelectAnos();
          const sel = document.getElementById('select-anos-receitas'); if(sel && sel.value) renderizarReceitasAno(sel.value);
          try{ closeImportPanelsAndHideQuickTools(); }catch(e){}
        } catch(err){ console.error(err); alert('Erro ao processar arquivos de cart√µes: ' + (err && err.message ? err.message : err)); }
        finally{ processarBtnCartao.disabled = false; }
      });
    }

    // ===== Processar PIX =====
    if(processarBtnPix){
      processarBtnPix.addEventListener('click', async ()=>{
        if (!arquivosSelecionadosPix.length) return;
        processarBtnPix.disabled = true;
  let resumoPorDia = {};
  let totalVendas = 0;
  let detalheBuffer = [];
        try{
          const savedMap = loadMapping('mapping_pix') || {};
          for (const arquivo of arquivosSelecionadosPix){
            const data = await readFileArrayBufferWithRetry(arquivo);
            const workbook = XLSX.read(new Uint8Array(data), {type:'array'});
            const sheet = workbook.Sheets[workbook.SheetNames[0]];
            const json = XLSX.utils.sheet_to_json(sheet, {header:1});

            const headerRowIndex = (typeof savedMap.headerRow === 'number') ? savedMap.headerRow : detectHeaderRow(json);
            const headers = (json[headerRowIndex] || []).map(h => h==null? '': String(h).trim());

            for (let i=headerRowIndex+1; i<json.length; i++){
              let row = json[i]; if(!row) continue;
              if (Array.isArray(row) && row.length===1 && typeof row[0]==='string' && row[0].includes(';')){ row = row[0].split(';').map(c => c==null ? '' : String(c).trim()); }

              const idxDate = applyMappingIndex(headers, savedMap.date || savedMap.data, 0);
              const idxStatus = applyMappingIndex(headers, savedMap.status || savedMap.statusVenda, 13);
              const idxValorBruto = applyMappingIndex(headers, savedMap.valorBruto || savedMap['valor bruto'], 16);
              const idxValorLiquido = applyMappingIndex(headers, savedMap.valorLiquido || savedMap['valor liquido'], 21);

              const dataRaw = row[idxDate];
              const status = String((row[idxStatus] || '') || '').trim().toLowerCase();
              if (!['approved','aprovado','concluida','conclu√≠do','concluido','liquidado'].some(s => status.includes(s))) continue;

              // obter data completa YYYY/MM/DD
              let anoMes = 'Indefinido';
              let anoMesDia = 'Indefinido';
              try{
                const dateObj = parseToJSDate(dataRaw);
                if (dateObj && !isNaN(dateObj.getTime())){
                  const y = dateObj.getFullYear(); const m = String(dateObj.getMonth()+1).padStart(2,'0'); const day = String(dateObj.getDate()).padStart(2,'0');
                  anoMes = `${y}/${m}`;
                  anoMesDia = `${y}/${m}/${day}`;
                } else {
                  const parsed = parseDateToAnoMes(dataRaw) || {}; anoMes = parsed.anoMes || 'Indefinido';
                }
              }catch(e){ anoMes = (parseDateToAnoMes(dataRaw)||{}).anoMes || 'Indefinido'; }

              const tipoPagamento = 'PIX';

              const valorBruto   = parseNumber(row[idxValorBruto]);
              const valorLiquido = parseNumber(row[idxValorLiquido]);
              const valorMDR = (valorBruto || 0) - (valorLiquido || 0);

              // save transaction-level detail for PIX
              try{
                // PIX: data e hora costumam vir juntas na mesma c√©lula (ex: '2025-01-15 13:45:00')
                const dt = extractDateTime(dataRaw);
                // store original dataRaw so normalizeVendaDetalhada can attempt robust parsing
                const rawObj = { date: dataRaw, dateMs: dt && dt.dateObj ? dt.dateObj.getTime() : null, time: dt && dt.timeStr ? dt.timeStr : null, valorBruto: valorBruto, mdr: valorMDR, valorLiquido: valorLiquido, source: 'pix', tipoPagamento };
                detalheBuffer.push(rawObj);
              }catch(e){ /* ignore */ }

              const keyDia = `${anoMesDia}||${tipoPagamento}`;
              if(!resumoPorDia[keyDia]) resumoPorDia[keyDia] = {receitaBruta:0, mdr:0, anoMesDia, anoMes, source:'pix', tipoPagamento};
              resumoPorDia[keyDia].receitaBruta   += valorBruto;
              resumoPorDia[keyDia].mdr            += valorMDR;
              resumoPorDia[keyDia].receitaLiquida  = resumoPorDia[keyDia].receitaBruta - resumoPorDia[keyDia].mdr;
              totalVendas++;
            }
          }
          // gravar vendas detalhadas em lote (mais eficiente) e reconstruir agrega√ß√µes a partir dos detalhes
          try{
            if(Array.isArray(detalheBuffer) && detalheBuffer.length>0){
              const beforeCount = (JSON.parse(localStorage.getItem('vendasDetalhadas')||'[]')||[]).filter(x=>x && x.source==='pix').length;
              const added = await addVendasDetalhadasBulk(detalheBuffer);
              const afterCount = (JSON.parse(localStorage.getItem('vendasDetalhadas')||'[]')||[]).filter(x=>x && x.source==='pix').length;
              console.info('[IMPORT PIX] detalheBuffer rows:', detalheBuffer.length, 'added(replaced):', added, 'before pix count:', beforeCount, 'after pix count:', afterCount);
              if(added > 0){ console.debug('[IMPORT PIX] sample added items:', JSON.parse(localStorage.getItem('vendasDetalhadas')||'[]').filter(x=>x && x.source==='pix').slice(Math.max(0, afterCount-10), afterCount)); }
            }
            const daily = rebuildDailyFromDetalhadas();
            const monthlyResumo = computeMonthlyResumoFromDaily();
            try { syncMdrToDespesas(monthlyResumo); } catch(e){ console.warn('syncMdrToDespesas falhou', e); }
            try{ computeWeekdaySumsPerMonth(); }catch(e){ /* ignore */ }
          }catch(e){ /* ignore */ }
          alert(`Importa√ß√£o PIX conclu√≠da: ${totalVendas} registros processados.`);
          atualizarSelectAnos();
          const sel = document.getElementById('select-anos-receitas'); if(sel && sel.value) renderizarReceitasAno(sel.value);
          try{ closeImportPanelsAndHideQuickTools(); }catch(e){}
        } catch(err){ console.error(err); alert('Erro ao processar arquivos PIX: ' + (err && err.message ? err.message : err)); }
        finally{ processarBtnPix.disabled = false; }
      });
    }

    
  </script>
</body>
</html>
